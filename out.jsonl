{"id":"e7cd49bd-02ae-4e9a-ab49-56a29bd449f0","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/docker/integration/topology/SkuMappingTopology.kt","symbol":"SkuMappingTopologyProvider","kind":"class","code":"\n@Configuration\nopen class SkuMappingTopologyProvider(\n    private val skuDao: SkuMappingDao,\n    @Value(\"\\${upshc.wmsId}\") private val wmsId: String\n) {\n  @Bean\n  open fun skuMappingTopology(\n      @Qualifier(\"skuMappingTopologyStreamBuilder\") builder: StreamsBuilder\n  ): KStream<String, Sku> {\n    return builder\n        .stream<String, Sku>(\"product.sku_public.v1\")\n        .filter { _, sku -> sku.wmsSkuIds?.keys?.contains(wmsId) ?: false }\n        .peek { _, sku ->\n          runBlocking {\n            skuDao.save(SkuMapping(sku.skuId, sku.organizationId, sku.wmsSkuIds!![wmsId]!!))\n          }\n        }\n  }\n}","metadata":{"parent":null}}
{"id":"7751ecab-c025-4e41-b4c2-270c1f1ea793","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/docker/integration/topology/SkuMappingTopology.kt","symbol":"SkuMappingTopologyProvider.skuMappingTopology","kind":"function","code":" @Bean\n  open fun skuMappingTopology(\n      @Qualifier(\"skuMappingTopologyStreamBuilder\") builder: StreamsBuilder\n  ): KStream<String, Sku> {\n    return builder\n        .stream<String, Sku>(\"product.sku_public.v1\")\n        .filter { _, sku -> sku.wmsSkuIds?.keys?.contains(wmsId) ?: false }\n        .peek { _, sku ->\n          runBlocking {\n            skuDao.save(SkuMapping(sku.skuId, sku.organizationId, sku.wmsSkuIds!![wmsId]!!))\n          }\n        }\n  }","metadata":{"modifiers":[],"annotations":[],"parent":"SkuMappingTopologyProvider"}}
{"id":"28df9592-eb83-443b-994c-85d74323bd32","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/docker/integration/Application.kt","symbol":"Application","kind":"class","code":"\n@SpringBootApplication(exclude = [ValidationAutoConfiguration::class,\n    PersistenceExceptionTranslationAutoConfiguration::class,\n    MetricsAutoConfiguration::class,\n    MongoAutoConfiguration::class,\n    MongoReactiveAutoConfiguration::class])\nopen class Application","metadata":{"parent":null}}
{"id":"78b7be61-6b5f-44fb-a90d-302a00d8a305","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/docker/integration/Application.kt","symbol":"main","kind":"function","code":"fun main(args: Array<String>) {\n    runApplication<Application>(*args)\n}","metadata":{"modifiers":[],"annotations":[],"parent":null}}
{"id":"fc5f654c-81d2-40a9-8c28-ebd67bfada7a","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/docker/integration/config/MongoConfig.kt","symbol":"MongoConfig","kind":"class","code":"\n@Configuration\nopen class MongoConfig {\n\n  @Bean\n  open fun mongoConfigBean(): MongoClientFactory {\n    return MongoClientFactory()\n  }\n\n  @Bean\n  open fun coroutineClient(mongoClientFactory: MongoClientFactory): CoroutineClient {\n    return mongoClientFactory.createCoroutineClient()\n  }\n\n  @Bean\n  open fun getDatabase(\n      coroutineClient: CoroutineClient,\n      @Value(\"\\${mongo.database}\") db: String\n  ): MongoDatabase {\n    return coroutineClient.getDatabase(db)\n  }\n}","metadata":{"parent":null}}
{"id":"5ae73c24-1c0c-405f-b3c8-bf52b73b87e6","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/docker/integration/config/MongoConfig.kt","symbol":"MongoConfig.mongoConfigBean","kind":"function","code":" @Bean\n  open fun mongoConfigBean(): MongoClientFactory {\n    return MongoClientFactory()\n  }","metadata":{"modifiers":[],"annotations":[],"parent":"MongoConfig"}}
{"id":"6d0a5c2b-27c1-4c6e-aa69-614899218412","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/docker/integration/config/MongoConfig.kt","symbol":"MongoConfig.coroutineClient","kind":"function","code":" @Bean\n  open fun coroutineClient(mongoClientFactory: MongoClientFactory): CoroutineClient {\n    return mongoClientFactory.createCoroutineClient()\n  }","metadata":{"modifiers":[],"annotations":[],"parent":"MongoConfig"}}
{"id":"5fee388f-089e-464c-9f9f-4fbdb957442c","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/docker/integration/config/MongoConfig.kt","symbol":"MongoConfig.getDatabase","kind":"function","code":" @Bean\n  open fun getDatabase(\n      coroutineClient: CoroutineClient,\n      @Value(\"\\${mongo.database}\") db: String\n  ): MongoDatabase {\n    return coroutineClient.getDatabase(db)\n  }","metadata":{"modifiers":[],"annotations":[],"parent":"MongoConfig"}}
{"id":"3d54cd1e-156c-4f1c-a030-db71c61835e6","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/docker/integration/config/StreamsConfig.kt","symbol":"StreamsConfig","kind":"class","code":"\n@Configuration\nopen class StreamsConfig {\n  @Bean\n  open fun runner(manager: StreamsBuilderFactoryManager): ApplicationRunner = ApplicationRunner {\n    manager.start()\n  }\n\n  @Bean\n  open fun skuMappingTopologyStreamBuilder(\n      kafkaProperties: KafkaProperties\n  ): StreamsBuilderFactoryBean {\n    val props = kafkaProperties.buildStreamsProperties()\n    props.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String()::class.java.name)\n    props.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, SkuSerde::class.java.name)\n    return StreamsBuilderFactoryBean(KafkaStreamsConfiguration(props))\n  }\n}","metadata":{"parent":null}}
{"id":"bc795af5-a2c4-42cd-9b2f-95086e6d41f3","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/docker/integration/config/StreamsConfig.kt","symbol":"StreamsConfig.runner","kind":"function","code":" @Bean\n  open fun runner(manager: StreamsBuilderFactoryManager): ApplicationRunner = ApplicationRunner {\n    manager.start()\n  }","metadata":{"modifiers":[],"annotations":[],"parent":"StreamsConfig"}}
{"id":"8a3aa8a2-353c-4d8e-88d9-c2ecea42ef3b","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/docker/integration/config/StreamsConfig.kt","symbol":"StreamsConfig.skuMappingTopologyStreamBuilder","kind":"function","code":" @Bean\n  open fun skuMappingTopologyStreamBuilder(\n      kafkaProperties: KafkaProperties\n  ): StreamsBuilderFactoryBean {\n    val props = kafkaProperties.buildStreamsProperties()\n    props.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String()::class.java.name)\n    props.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, SkuSerde::class.java.name)\n    return StreamsBuilderFactoryBean(KafkaStreamsConfiguration(props))\n  }","metadata":{"modifiers":[],"annotations":[],"parent":"StreamsConfig"}}
{"id":"0e41cb09-efcb-40ed-9b2b-b20f88e0b8f2","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/docker/integration/config/StreamsConfig.kt","symbol":"SkuSerde","kind":"class","code":"class SkuSerde : Serde<Sku> {\n\n  override fun serializer(): Serializer<Sku> {\n    return object : Serializer<Sku> {\n      override fun serialize(topic: String?, data: Sku?): ByteArray {\n        if(data == null) {\n          return ByteArray(0)\n        }\n        return JsonConfig.json.encodeToString(Sku.serializer(), data).toByteArray(Charsets.UTF_8)\n      }\n    }\n  }\n\n  override fun deserializer(): Deserializer<Sku> {\n    return object : Deserializer<Sku> {\n      override fun deserialize(topic: String?, data: ByteArray?): Sku? {\n        if(data == null || data.isEmpty()) {\n          return null\n        }\n        return JsonConfig.json.decodeFromString(Sku.serializer(), String(data))\n      }\n    }\n  }\n}","metadata":{"parent":null}}
{"id":"f948cdcf-3739-4cff-8948-f5e856cd484b","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/docker/integration/config/StreamsConfig.kt","symbol":"SkuSerde.serializer","kind":"function","code":"override fun serializer(): Serializer<Sku> {\n    return object : Serializer<Sku> {\n      override fun serialize(topic: String?, data: Sku?): ByteArray {\n        if(data == null) {\n          return ByteArray(0)\n        }\n        return JsonConfig.json.encodeToString(Sku.serializer(), data).toByteArray(Charsets.UTF_8)\n      }\n    }\n  }","metadata":{"modifiers":[],"annotations":[],"parent":"SkuSerde"}}
{"id":"e854c752-89ac-4848-b99e-1eaba299cda6","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/docker/integration/config/StreamsConfig.kt","symbol":"SkuSerde.deserializer","kind":"function","code":"override fun deserializer(): Deserializer<Sku> {\n    return object : Deserializer<Sku> {\n      override fun deserialize(topic: String?, data: ByteArray?): Sku? {\n        if(data == null || data.isEmpty()) {\n          return null\n        }\n        return JsonConfig.json.decodeFromString(Sku.serializer(), String(data))\n      }\n    }\n  }","metadata":{"modifiers":[],"annotations":[],"parent":"SkuSerde"}}
{"id":"8ed6316c-b545-4056-b07b-c5f4aec7d102","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/docker/integration/dao/SkuMappingDao.kt","symbol":"SkuMappingDao","kind":"class","code":"\n@Service\nclass SkuMappingDao(db: MongoDatabase) {\n  private val collection = db.getCollection<SkuMapping>(\"sku_mapping\")\n\n  suspend fun save(mapping: SkuMapping) {\n    collection.updateOne(\n      SkuMapping::_id eq mapping._id,\n      combine(\n        setValue(SkuMapping::updatedAt, Instant.now()),\n        setValue(SkuMapping::skuId, mapping.skuId),\n        setValue(SkuMapping::upsHcSkuId, mapping.upsHcSkuId),\n        setValue(SkuMapping::organizationId, mapping.organizationId),\n        setOnInsert(SkuMapping::createdAt, Instant.now())\n      ),\n      UpdateOptions().upsert(true))\n  }\n\n  fun search(field: String,\n             value: String): AggregateFlow<SkuMapping> =\n    collection.aggregate<SkuMapping>(listOf(Aggregates.search(SearchOperator.text(SearchPath.fieldPath(field), value),\n      SearchOptions.searchOptions().index(\"sku-mapping-v1\"))))\n}","metadata":{"parent":null}}
{"id":"47fa7fc4-8e3b-4cba-877a-ae8f05925863","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/docker/integration/dao/SkuMappingDao.kt","symbol":"SkuMappingDao.save","kind":"function","code":"suspend fun save(mapping: SkuMapping) {\n    collection.updateOne(\n      SkuMapping::_id eq mapping._id,\n      combine(\n        setValue(SkuMapping::updatedAt, Instant.now()),\n        setValue(SkuMapping::skuId, mapping.skuId),\n        setValue(SkuMapping::upsHcSkuId, mapping.upsHcSkuId),\n        setValue(SkuMapping::organizationId, mapping.organizationId),\n        setOnInsert(SkuMapping::createdAt, Instant.now())\n      ),\n      UpdateOptions().upsert(true))\n  }","metadata":{"modifiers":[],"annotations":[],"parent":"SkuMappingDao"}}
{"id":"5343f402-a5ec-42c3-8ace-985056e40fe4","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/docker/integration/dao/SkuMappingDao.kt","symbol":"SkuMappingDao.search","kind":"function","code":"fun search(field: String,\n             value: String): AggregateFlow<SkuMapping> =\n    collection.aggregate<SkuMapping>(listOf(Aggregates.search(SearchOperator.text(SearchPath.fieldPath(field), value),\n      SearchOptions.searchOptions().index(\"sku-mapping-v1\"))))","metadata":{"modifiers":[],"annotations":[],"parent":"SkuMappingDao"}}
{"id":"61535f43-5f6b-477f-94f2-da34063abf01","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/docker/integration/model/SkuMapping.kt","symbol":"SkuMapping","kind":"class","code":"\n@Serializable\ndata class SkuMapping(\n    val skuId: String,\n    val organizationId: String,\n    val upsHcSkuId: String,\n    @Contextual val createdAt: Instant = Instant.now(),\n    @Contextual val updatedAt: Instant = createdAt,\n) {\n  val _id: String = \"$organizationId:$skuId\"\n}","metadata":{"parent":null}}
{"id":"2ddf0f23-5c45-4bc8-8e4e-4ad0902dc30c","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/test/AbstractSpringBootIntegrationTestSpec.kt","symbol":"AbstractSpringBootIntegrationSpec","kind":"class","code":"\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\nabstract class AbstractSpringBootIntegrationSpec(\n    body: DescribeSpec.() -> Unit = {}\n) : DescribeSpec(body) {\n\n    @LocalServerPort\n    var randomPort: Int = 0\n\n    val extension: List<Extension> =\n        listOf(SharedDockerEnvironment, SpringExtension)\n\n    override fun extensions(): List<Extension> = extension\n\n    init {\n        body()\n    }\n}","metadata":{"parent":null}}
{"id":"eef6b87b-6b01-4d7f-afc9-8b7f9023194f","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/test/AbstractSpringBootIntegrationTestSpec.kt","symbol":"AbstractSpringBootIntegrationSpec.extensions","kind":"function","code":"override fun extensions(): List<Extension> = extension","metadata":{"modifiers":[],"annotations":[],"parent":"AbstractSpringBootIntegrationSpec"}}
{"id":"7105fcda-e8cd-406d-bd3a-41ff15120c75","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/test/AbstractSpringBootIntegrationTestSpec.kt","symbol":"extensions","kind":"function","code":"override fun extensions(): List<Extension> {\n        return listOf(SharedDockerEnvironment)\n    }","metadata":{"modifiers":[],"annotations":[],"parent":null}}
{"id":"8de32cc5-c063-4fbf-a876-759a4e1cb4ba","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/test/AbstractSpringBootIntegrationTestSpec.kt","symbol":"CustomMongoConfig","kind":"class","code":"class CustomMongoConfig(\n    enabled: Boolean = true,\n    enableMigration: Boolean = enabled,\n    migrationClasspathDir: String = \"../infra/pulumi/pre/migrations\",\n    database: String = \"admin\",\n    username: String = \"admin\",\n    password: String = \"admin\",\n    atlasSearchDefinitions: List<String> = emptyList(),\n    persistenceStrategy: PersistenceStrategy = EphemeralPersistence(),\n) : IntegrationTestMongoConfig(enabled, enableMigration, migrationClasspathDir, database, username, password, atlasSearchDefinitions, persistenceStrategy){\n\n    private val logger = KotlinLogging.logger {}\n\n    override fun customConfiguration(container: GenericContainer<*>) {\n        logger.info { \"I have access to configure the container\" }\n    }\n}","metadata":{"parent":null}}
{"id":"fdad3454-4a54-4f9d-a545-b122d8d33fce","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/test/AbstractSpringBootIntegrationTestSpec.kt","symbol":"CustomMongoConfig.customConfiguration","kind":"function","code":"override fun customConfiguration(container: GenericContainer<*>) {\n        logger.info { \"I have access to configure the container\" }\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"CustomMongoConfig"}}
{"id":"540ef768-a591-436c-ae35-baa35de9b26a","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/test/AutowiredAbstractTestSpec.kt","symbol":"AutowiredAbstractTestSpec","kind":"class","code":"abstract class AutowiredAbstractTestSpec(spec: AutowiredAbstractTestSpec.() -> Unit = {}):\n    AbstractSpringBootIntegrationSpec(){\n    init {\n        spec()\n    }\n\n    @Autowired lateinit var kafkaProperties: KafkaProperties\n\n    @Autowired lateinit var db: MongoDatabase\n\n    @Autowired lateinit var dao: SkuMappingDao\n}","metadata":{"parent":null}}
{"id":"a0924017-0a78-43c5-b82e-67d840a28cf2","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/test/AppStartSpec.kt","symbol":"AppStartSpec","kind":"class","code":"class AppStartSpec:AbstractAppStarterDescribeSpec(testContainers){\n    val extension: List<Extension> =\n        listOf(SharedDockerEnvironment, SpringExtension)\n\n    override fun extensions(): List<Extension> = extension\n}","metadata":{"parent":null}}
{"id":"178bc781-4d14-4804-808a-c84837a4f38d","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/test/AppStartSpec.kt","symbol":"AppStartSpec.extensions","kind":"function","code":"override fun extensions(): List<Extension> = extension","metadata":{"modifiers":[],"annotations":[],"parent":"AppStartSpec"}}
{"id":"05aa365c-e9db-4df9-a7c3-a07fa7e8b0d1","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/test/kotlin/com/w2g/test/StartableTestContainersSpec.kt","symbol":"StartableTestContainersSpec","kind":"class","code":"\n@ContextConfiguration(classes = [Application::class])\nclass StartableTestContainersSpec : AutowiredAbstractTestSpec({\n\n    describe(\"Spring Boot Streams Application\") {\n        val topic = \"product.sku_public.v1\"\n        val organizationId = RandomStringUtils.randomAlphanumeric(5)\n        it(\"should save sku mapping\") {\n            val skuId = RandomStringUtils.randomAlphanumeric(5)\n            val template =\n                KafkaTemplate<String, Sku>(\n                    DefaultKafkaProducerFactory(\n                        kafkaProperties.buildProducerProperties(),\n                        StringSerializer(),\n                        JsonSerializer()\n                    )\n                )\n            val externalId = RandomStringUtils.randomAlphanumeric(8)\n\n            template\n                .send(\n                    topic,\n                    skuId,\n                    Sku(\n                        isActive = true,\n                        organizationId = organizationId,\n                        skuId = skuId,\n                        wmsSkuIds = mapOf(\"test-wms-id\" to externalId))\n                )\n                .get(10, TimeUnit.SECONDS)\n\n            val collection = db.getCollection<SkuMapping>(\"sku_mapping\")\n            var doc: SkuMapping? = null\n            await.atMost(Duration.ofSeconds(200)) untilNotNull {\n                runBlocking {\n                    doc = collection.findOne(SkuMapping::skuId eq skuId)\n                    doc\n                }\n            }\n            doc?.skuId shouldBe skuId\n            doc?.upsHcSkuId shouldBe externalId\n            eventually(10.seconds) {\n                dao.search(\"skuId\",skuId).toList() shouldBe listOf(doc)\n            }\n        }\n    }\n})","metadata":{"parent":null}}
{"id":"b13b1c8f-4057-4b2d-b0a6-7b5393e9ae96","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/specs/AbstractAppStarterDescribeSpec.kt","symbol":"AbstractAppStarterDescribeSpec","kind":"class","code":"\n@Tags(\"RunApp\")\nabstract class AbstractAppStarterDescribeSpec(\n    open val testContainers: StartableTestContainers,\n    body: DescribeSpec.() -> Unit = {}\n):DescribeSpec(body) {\n\n    open fun startupLog() {\n        println(\"App is running\")\n    }\n\n    init {\n        describe(\"Run App\"){\n            it(\"Keeps App Open\") {\n                startupLog()\n\n                // Keep the app running\n                val shutdownHook = Thread {\n                    println(\"Shutting down app...\")\n                    testContainers.stop()\n                }\n                Runtime.getRuntime().addShutdownHook(shutdownHook)\n\n                while (true) {\n                    Thread.sleep(1000) // Sleep to reduce CPU usage in the loop\n                }\n            }\n        }\n    }\n}","metadata":{"parent":null}}
{"id":"bbe219ae-d0e5-4352-8616-2343de999fc1","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/specs/AbstractAppStarterDescribeSpec.kt","symbol":"AbstractAppStarterDescribeSpec.startupLog","kind":"function","code":"open fun startupLog() {\n        println(\"App is running\")\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"AbstractAppStarterDescribeSpec"}}
{"id":"16ec5a50-2464-4830-858e-3426aa17c969","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/specs/MongoDatabaseAtlasEnabledSpec.kt","symbol":"MongoDatabaseAtlasEnabledSpec","kind":"class","code":"abstract class MongoDatabaseAtlasEnabledSpec(\n    private val database: String,\n    private val mongoExtension: MongoEnvironmentExtension = MongoEnvironmentExtension(database),\n    /** Applied after [mongoExtension] */\n    private vararg val additionalExtensions: Extension,\n) : DescribeSpec() {\n    protected lateinit var syncDb: MongoDatabase\n    protected lateinit var coroutineDb: CoroutineMongoDatabase\n\n    override fun extensions(): List<Extension> {\n        return listOf(mongoExtension) + additionalExtensions\n    }\n\n    open fun mongoConfig(testContainers: StartableTestContainers): MongoConfig {\n        return MongoConfig(\n            connectionString = \"mongodb://localhost:${testContainers.mongo!!.port}\",\n            authDatabase = \"admin\",\n            database = testContainers.mongo!!.config.database,\n            user = testContainers.mongo!!.config.username,\n            password = testContainers.mongo!!.config.password,\n            maxPoolSize = 16\n        )\n    }\n\n    override suspend fun beforeSpec(spec: Spec) {\n        val config = mongoConfig(mongoExtension.testContainers)\n        coroutineDb =\n            MongoClientFactory(config).createCoroutineClient().getDatabase(config.database)\n        syncDb = MongoClientFactory(config).createSyncClient().getDatabase(config.database)\n    }\n}","metadata":{"parent":null}}
{"id":"8324130f-4eb0-4339-9680-9c9c166a205d","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/specs/MongoDatabaseAtlasEnabledSpec.kt","symbol":"MongoDatabaseAtlasEnabledSpec.extensions","kind":"function","code":"override fun extensions(): List<Extension> {\n        return listOf(mongoExtension) + additionalExtensions\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"MongoDatabaseAtlasEnabledSpec"}}
{"id":"ec701921-6445-4c1a-aa51-a818bc6a43b6","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/specs/MongoDatabaseAtlasEnabledSpec.kt","symbol":"MongoDatabaseAtlasEnabledSpec.mongoConfig","kind":"function","code":"open fun mongoConfig(testContainers: StartableTestContainers): MongoConfig {\n        return MongoConfig(\n            connectionString = \"mongodb://localhost:${testContainers.mongo!!.port}\",\n            authDatabase = \"admin\",\n            database = testContainers.mongo!!.config.database,\n            user = testContainers.mongo!!.config.username,\n            password = testContainers.mongo!!.config.password,\n            maxPoolSize = 16\n        )\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"MongoDatabaseAtlasEnabledSpec"}}
{"id":"867c3159-cc07-40e8-b80a-2420d6ea1b01","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/specs/MongoDatabaseAtlasEnabledSpec.kt","symbol":"MongoDatabaseAtlasEnabledSpec.beforeSpec","kind":"function","code":"override suspend fun beforeSpec(spec: Spec) {\n        val config = mongoConfig(mongoExtension.testContainers)\n        coroutineDb =\n            MongoClientFactory(config).createCoroutineClient().getDatabase(config.database)\n        syncDb = MongoClientFactory(config).createSyncClient().getDatabase(config.database)\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"MongoDatabaseAtlasEnabledSpec"}}
{"id":"e8723de8-e926-413c-b80b-39f982160ea5","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/specs/AbstractSpringBootWebAppStarterDescribeSpec.kt","symbol":"AbstractSpringBootWebAppStarterDescribeSpec","kind":"class","code":"abstract class AbstractSpringBootWebAppStarterDescribeSpec(\n    testContainers: StartableTestContainers,\n    body: DescribeSpec.() -> Unit = {}\n): AbstractAppStarterDescribeSpec(testContainers,body) {\n\n    abstract fun port(): Int\n\n    abstract fun bearerToken(): String\n\n    override fun startupLog() {\n        println(\"App is running. You can send the app requests using Postman or Conduktor.\")\n        println(\"App is starting on port ${port()}. Use bearer token \\n${bearerToken()}\")\n    }\n}","metadata":{"parent":null}}
{"id":"777b93b8-b392-4e4a-9ffc-eb1c8cf85baf","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/specs/AbstractSpringBootWebAppStarterDescribeSpec.kt","symbol":"AbstractSpringBootWebAppStarterDescribeSpec.port","kind":"function","code":"abstract fun port(): Int","metadata":{"modifiers":[],"annotations":[],"parent":"AbstractSpringBootWebAppStarterDescribeSpec"}}
{"id":"332bc8be-ee74-4273-8868-00b52f10c297","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/specs/AbstractSpringBootWebAppStarterDescribeSpec.kt","symbol":"AbstractSpringBootWebAppStarterDescribeSpec.bearerToken","kind":"function","code":"abstract fun bearerToken(): String","metadata":{"modifiers":[],"annotations":[],"parent":"AbstractSpringBootWebAppStarterDescribeSpec"}}
{"id":"f71f0bc5-0cf1-4795-85c0-c0e74c2b81fc","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/specs/AbstractSpringBootWebAppStarterDescribeSpec.kt","symbol":"AbstractSpringBootWebAppStarterDescribeSpec.startupLog","kind":"function","code":"override fun startupLog() {\n        println(\"App is running. You can send the app requests using Postman or Conduktor.\")\n        println(\"App is starting on port ${port()}. Use bearer token \\n${bearerToken()}\")\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"AbstractSpringBootWebAppStarterDescribeSpec"}}
{"id":"ccce43bd-5e3c-4e00-9c8f-c9e0f4194d1c","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/PersistenceStrategy.kt","symbol":"PersistenceStrategy","kind":"class","code":"interface PersistenceStrategy {\n    fun configure(container: GenericContainer<*>) {}\n}","metadata":{"parent":null}}
{"id":"42642787-6cef-41bd-8a81-514516af9cb0","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/PersistenceStrategy.kt","symbol":"PersistenceStrategy.configure","kind":"function","code":"fun configure(container: GenericContainer<*>) {}","metadata":{"modifiers":[],"annotations":[],"parent":"PersistenceStrategy"}}
{"id":"dca0f727-836e-4dfd-a818-d61e9386226c","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/PersistenceStrategy.kt","symbol":"EphemeralPersistence","kind":"class","code":"class EphemeralPersistence : PersistenceStrategy {}","metadata":{"parent":null}}
{"id":"a74a3362-dbaa-4eb2-9557-783ea1ff904c","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/PersistenceStrategy.kt","symbol":"BindToHostPersistence","kind":"class","code":"class BindToHostPersistence(private val hostPath:String, private val containerPath:String) : PersistenceStrategy {\n    override fun configure(container: GenericContainer<*>) {\n        container.withFileSystemBind(hostPath, containerPath)\n    }\n}","metadata":{"parent":null}}
{"id":"fc389d1f-bd84-40ff-9b30-4e9fee2d7d29","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/PersistenceStrategy.kt","symbol":"BindToHostPersistence.configure","kind":"function","code":"override fun configure(container: GenericContainer<*>) {\n        container.withFileSystemBind(hostPath, containerPath)\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"BindToHostPersistence"}}
{"id":"e54431a0-d7ff-4391-bfa3-ef79d0cc90f2","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/StartableTestContainers.kt","symbol":"StartableTestContainers","kind":"class","code":"open class StartableTestContainers(\n    private val mongoConfig: IntegrationTestMongoConfig? = null,\n    private val kafkaConfig: IntegrationTestKafkaConfig? = null,\n    private val wireMockConfig: IntegrationTestWireMockConfig? = null,\n    private val gcsConfig: IntegrationTestGcsConfig? = null,\n    private val bigQueryConfig: IntegrationTestBigQueryConfig? = null,\n    private val postgresConfig: IntegrationTestPostgresConfig? = null,\n    private val redisConfig: IntegrationTestRedisConfig? = null,\n    private val schemaRegistryConfig: IntegrationTestSchemaRegistryConfig? = null\n) : Startable {\n    private var isStarted: Boolean = false\n\n    private val gcsMappedPort = Random.nextInt(30000, 40000)\n\n    init {\n        System.setProperty(\"testcontainers.client.timeout\", \"5000\")\n    }\n\n    fun isStarted(): Boolean {\n        return isStarted\n    }\n\n    open val network: Network = Network.newNetwork()\n\n    open val mongoMigration: MongoMigrationContainer?\n            by lazy {\n                if (mongoConfig?.enableMigration == true) MongoMigrationContainer(network, mongo!!, mongoConfig)\n                else null\n            }\n\n\n    open val mongo: MongoContainer?\n            by lazy {\n                if (mongoConfig?.enabled == true) MongoContainer(network, mongoConfig)\n                else null\n            }\n\n    open val kafka: KafkaContainer?\n            by lazy {\n                if (kafkaConfig?.enabled == true) KafkaContainer(network, kafkaConfig)\n                else null\n            }\n\n    open val schemaRegistry: Container<*>?\n            by lazy {\n                if(schemaRegistryConfig?.enabled == true) SchemaRegistryContainer(network, kafka!!, schemaRegistryConfig) else null\n            }\n\n\n    open val wiremock: WireMockContainer?\n            by lazy {\n                if (wireMockConfig?.enabled == true) WireMockContainer(network, wireMockConfig)\n                else null\n            }\n\n    open val gcs: GCSContainer?\n            by lazy {\n                if (gcsConfig?.enabled == true) GCSContainer(gcsMappedPort, network, gcsConfig)\n                else null\n            }\n\n    open val bigQuery: BigQueryContainer?\n            by lazy {\n                if (bigQueryConfig?.enabled == true) BigQueryContainer(network, bigQueryConfig)\n                else null\n            }\n\n    open val postgres: PostgresContainer?\n            by lazy {\n                if (postgresConfig?.enabled == true) PostgresContainer(network, postgresConfig)\n                else null\n            }\n\n    open val redis: RedisContainer?\n            by lazy {\n                if (redisConfig?.enabled == true) RedisContainer(network, redisConfig)\n                else null\n            }\n\n\n    open val extraContainers: List<Container<*>>\n        get() {\n            return listOf()\n        }\n\n    open fun getContainers(): Set<Container<*>> {\n        return setOfNotNull(\n            mongoMigration,\n            mongo,\n            kafka,\n            schemaRegistry,\n            wiremock,\n            gcs,\n            bigQuery,\n            postgres,\n            redis,\n        ) + extraContainers\n    }\n\n    override fun start() {\n        val containers = getContainers()\n        val containersThatAreDependedOn = containers.flatMap { it.container.dependencies }.toSet()\n        val containersToStart = containers.filter { !containersThatAreDependedOn.contains(it.container) }\n        containersToStart.forEach { it.container.start() }\n        waitForContainersReady()\n        containers.forEach { it.afterStart() }\n        isStarted = true\n    }\n\n    override fun stop() {\n        getContainers().forEach { it.container.stop() }\n        isStarted = false\n    }\n\n    open fun waitForContainersReady() {\n        Thread.sleep(2000)\n    }\n}","metadata":{"parent":null}}
{"id":"09d46ddc-4325-4fb2-9eb3-6284de1015dc","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/StartableTestContainers.kt","symbol":"StartableTestContainers.isStarted","kind":"function","code":"fun isStarted(): Boolean {\n        return isStarted\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"StartableTestContainers"}}
{"id":"5fd441f2-76c7-4557-84fd-a0d1a00d456c","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/StartableTestContainers.kt","symbol":"StartableTestContainers.getContainers","kind":"function","code":"open fun getContainers(): Set<Container<*>> {\n        return setOfNotNull(\n            mongoMigration,\n            mongo,\n            kafka,\n            schemaRegistry,\n            wiremock,\n            gcs,\n            bigQuery,\n            postgres,\n            redis,\n        ) + extraContainers\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"StartableTestContainers"}}
{"id":"49a25b80-fdb0-49d6-abab-aeb0a72942d2","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/StartableTestContainers.kt","symbol":"StartableTestContainers.start","kind":"function","code":"override fun start() {\n        val containers = getContainers()\n        val containersThatAreDependedOn = containers.flatMap { it.container.dependencies }.toSet()\n        val containersToStart = containers.filter { !containersThatAreDependedOn.contains(it.container) }\n        containersToStart.forEach { it.container.start() }\n        waitForContainersReady()\n        containers.forEach { it.afterStart() }\n        isStarted = true\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"StartableTestContainers"}}
{"id":"50810f2c-f87d-4fbc-a63c-ec3338e8b765","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/StartableTestContainers.kt","symbol":"StartableTestContainers.stop","kind":"function","code":"override fun stop() {\n        getContainers().forEach { it.container.stop() }\n        isStarted = false\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"StartableTestContainers"}}
{"id":"6da08768-6a8a-43cb-9f1e-7a3055f93177","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/StartableTestContainers.kt","symbol":"StartableTestContainers.waitForContainersReady","kind":"function","code":"open fun waitForContainersReady() {\n        Thread.sleep(2000)\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"StartableTestContainers"}}
{"id":"fa0b35db-d85c-4642-9b7b-f3af0cf8f80e","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/StartableTestContainers.kt","symbol":"Container","kind":"class","code":"abstract class Container<CONFIG> {\n\n    protected abstract val dockerPort: Int\n\n    abstract val container: GenericContainer<*>\n\n    open val port: Int?\n        get() = container.getMappedPort(dockerPort)\n\n    abstract val config: CONFIG\n\n    open val clientEnv: Map<String, String> = emptyMap()\n\n    open fun afterStart() {}\n}","metadata":{"parent":null}}
{"id":"33bb53d3-5797-4685-b101-8d7ba80c7446","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/StartableTestContainers.kt","symbol":"Container.afterStart","kind":"function","code":"open fun afterStart() {}","metadata":{"modifiers":[],"annotations":[],"parent":"Container"}}
{"id":"88f05fc1-0ecd-4df6-8ae9-ba451810b610","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/StartableTestContainers.kt","symbol":"apply","kind":"function","code":"fun GenericContainer<*>.apply(config: IntegrationTestContainerConfig) =\n    config.configure(this)","metadata":{"modifiers":[],"annotations":[],"parent":null}}
{"id":"8e061775-5f7c-4442-ab22-f0aa5e2dba37","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/utils/OpenIdConfiguration.kt","symbol":"OpenIdConfiguration","kind":"class","code":"\n@Serializable\ndata class OpenIdConfiguration(\n    val issuer: String,\n    @SerialName(\"authorization_endpoint\")\n    val authorizationEndpoint: String,\n    @SerialName(\"token_endpoint\")\n    val tokenEndpoint: String,\n    @SerialName(\"introspection_endpoint\")\n    val introspectionEndpoint: String,\n    @SerialName(\"userinfo_endpoint\")\n    val userInfoEndpoint: String,\n    @SerialName(\"jwks_uri\")\n    val jwksUri: String,\n    @SerialName(\"registration_endpoint\")\n    val registrationEndpoint: String,\n    @SerialName(\"revocation_endpoint\")\n    val revocationEndpoint: String,\n    @SerialName(\"device_authorization_endpoint\")\n    val deviceAuthorizationEndpoint: String,\n    @SerialName(\"backchannel_authentication_endpoint\")\n    val backchannelAuthenticationEndpoint: String,\n    @SerialName(\"pushed_authorization_request_endpoint\")\n    val pushedAuthorizationRequestEndpoint: String,\n    @SerialName(\"check_session_iframe\")\n    val checkSessionIframe: String,\n    @SerialName(\"frontchannel_logout_session_supported\")\n    val frontchannelLogoutSessionSupported: Boolean = true,\n    @SerialName(\"frontchannel_logout_supported\")\n    val frontchannelLogoutSupported: Boolean = true,\n    @SerialName(\"grant_types_supported\")\n    val grantTypesSupported: List<String> = listOf(\n        \"authorization_code\",\n        \"implicit\",\n        \"refresh_token\",\n        \"password\",\n        \"client_credentials\",\n        \"urn:ietf:params:oauth:grant-type:device_code\",\n        \"urn:openid:params:grant-type:ciba\"\n    ),\n    @SerialName(\"acr_values_supported\")\n    val acrValuesSupported: List<String> = listOf(\"0\", \"1\"),\n    @SerialName(\"response_types_supported\")\n    val responseTypesSupported: List<String> = listOf(\n        \"code\",\n        \"none\",\n        \"id_token\",\n        \"token\",\n        \"id_token token\",\n        \"code id_token\",\n        \"code token\",\n        \"code id_token token\"\n    ),\n    @SerialName(\"subject_types_supported\")\n    val subjectTypesSupported: List<String> = listOf(\n        \"public\",\n        \"pairwise\"\n    ),\n    @SerialName(\"id_token_signing_alg_values_supported\")\n    val idTokenSigningAlgValuesSupported: List<String> = listOf(\n        \"PS384\",\n        \"ES384\",\n        \"RS384\",\n        \"HS256\",\n        \"HS512\",\n        \"ES256\",\n        \"RS256\",\n        \"HS384\",\n        \"ES512\",\n        \"PS256\",\n        \"PS512\",\n        \"RS512\"\n    ),\n    @SerialName(\"id_token_encryption_alg_values_supported\")\n    val idTokenEncryptionAlgValuesSupported: List<String> = listOf(\n        \"RSA-OAEP\",\n        \"RSA-OAEP-256\",\n        \"RSA1_5\"\n    ),\n    @SerialName(\"id_token_encryption_enc_values_supported\")\n    val idTokenEncryptionEncValuesSupported: List<String> = listOf(\n        \"A256GCM\",\n        \"A192GCM\",\n        \"A128GCM\",\n        \"A128CBC-HS256\",\n        \"A192CBC-HS384\",\n        \"A256CBC-HS512\"\n    ),\n    @SerialName(\"userinfo_signing_alg_values_supported\")\n    val userinfoSigningAlgValuesSupported: List<String> = listOf(\n        \"PS384\",\n        \"ES384\",\n        \"RS384\",\n        \"HS256\",\n        \"HS512\",\n        \"ES256\",\n        \"RS256\",\n        \"HS384\",\n        \"ES512\",\n        \"PS256\",\n        \"PS512\",\n        \"RS512\",\n        \"none\"\n    ),\n    @SerialName(\"userinfo_encryption_alg_values_supported\")\n    val userinfoEncryptionAlgValuesSupported: List<String> = listOf(\n        \"RSA-OAEP\",\n        \"RSA-OAEP-256\",\n        \"RSA1_5\"\n    ),\n    @SerialName(\"userinfo_encryption_enc_values_supported\")\n    val userinfoEncryptionEncValuesSupported: List<String> = listOf(\n        \"A256GCM\",\n        \"A192GCM\",\n        \"A128GCM\",\n        \"A128CBC-HS256\",\n        \"A192CBC-HS384\",\n        \"A256CBC-HS512\"\n    ),\n    @SerialName(\"request_object_signing_alg_values_supported\")\n    val requestObjectSigningAlgValuesSupported: List<String> = listOf(\n        \"PS384\",\n        \"ES384\",\n        \"RS384\",\n        \"HS256\",\n        \"HS512\",\n        \"ES256\",\n        \"RS256\",\n        \"HS384\",\n        \"ES512\",\n        \"PS256\",\n        \"PS512\",\n        \"RS512\",\n        \"none\"\n    ),\n    @SerialName(\"request_object_encryption_alg_values_supported\")\n    val requestObjectEncryptionAlgValuesSupported: List<String> = listOf(\n        \"RSA-OAEP\",\n        \"RSA-OAEP-256\",\n        \"RSA1_5\"\n    ),\n    @SerialName(\"request_object_encryption_enc_values_supported\")\n    val requestObjectEncryptionEncValuesSupported: List<String> = listOf(\n        \"A256GCM\",\n        \"A192GCM\",\n        \"A128GCM\",\n        \"A128CBC-HS256\",\n        \"A192CBC-HS384\",\n        \"A256CBC-HS512\"\n    ),\n    @SerialName(\"response_modes_supported\")\n    val responseModesSupported: List<String> = listOf(\n        \"query\",\n        \"fragment\",\n        \"form_post\",\n        \"query.jwt\",\n        \"fragment.jwt\",\n        \"form_post.jwt\",\n        \"jwt\"\n    ),\n    @SerialName(\"token_endpoint_auth_methods_supported\")\n    val tokenEndpointAuthMethodsSupported: List<String> = listOf(\n        \"private_key_jwt\",\n        \"client_secret_basic\",\n        \"client_secret_post\",\n        \"tls_client_auth\",\n        \"client_secret_jwt\"\n    ),\n    @SerialName(\"token_endpoint_auth_signing_alg_values_supported\")\n    val tokenEndpointAuthSigningAlgValuesSupported: List<String> = listOf(\n        \"PS384\",\n        \"ES384\",\n        \"RS384\",\n        \"HS256\",\n        \"HS512\",\n        \"ES256\",\n        \"RS256\",\n        \"HS384\",\n        \"ES512\",\n        \"PS256\",\n        \"PS512\",\n        \"RS512\"\n    ),\n    @SerialName(\"introspection_endpoint_auth_methods_supported\")\n    val introspectionEndpointAuthMethodsSupported: List<String> = listOf(\n        \"private_key_jwt\",\n        \"client_secret_basic\",\n        \"client_secret_post\",\n        \"tls_client_auth\",\n        \"client_secret_jwt\"\n    ),\n    @SerialName(\"introspection_endpoint_auth_signing_alg_values_supported\")\n    val introspectionEndpointAuthSigningAlgValuesSupported: List<String> = listOf(\n        \"PS384\",\n        \"ES384\",\n        \"RS384\",\n        \"HS256\",\n        \"HS512\",\n        \"ES256\",\n        \"RS256\",\n        \"HS384\",\n        \"ES512\",\n        \"PS256\",\n        \"PS512\",\n        \"RS512\"\n    ),\n    @SerialName(\"authorization_signing_alg_values_supported\")\n    val authorizationSigningAlgValuesSupported: List<String> = listOf(\n        \"PS384\",\n        \"ES384\",\n        \"RS384\",\n        \"HS256\",\n        \"HS512\",\n        \"ES256\",\n        \"RS256\",\n        \"HS384\",\n        \"ES512\",\n        \"PS256\",\n        \"PS512\",\n        \"RS512\"\n    ),\n    @SerialName(\"authorization_encryption_alg_values_supported\")\n    val authorizationEncryptionAlgValuesSupported: List<String> = listOf(\n        \"RSA-OAEP\",\n        \"RSA-OAEP-256\",\n        \"RSA1_5\"\n    ),\n    @SerialName(\"authorization_encryption_enc_values_supported\")\n    val authorizationEncryptionEncValuesSupported: List<String> = listOf(\n        \"A256GCM\",\n        \"A192GCM\",\n        \"A128GCM\",\n        \"A128CBC-HS256\",\n        \"A192CBC-HS384\",\n        \"A256CBC-HS512\"\n    ),\n    @SerialName(\"claims_supported\")\n    val claimsSupported: List<String> = listOf(\n        \"aud\",\n        \"sub\",\n        \"iss\",\n        \"auth_time\",\n        \"name\",\n        \"given_name\",\n        \"family_name\",\n        \"preferred_username\",\n        \"email\",\n        \"acr\"\n    ),\n    @SerialName(\"claim_types_supported\")\n    val claimTypesSupported: List<String> = listOf(\n        \"normal\"\n    ),\n    @SerialName(\"claims_parameter_supported\")\n    val claimsParameterSupported: Boolean = true,\n    @SerialName(\"scopes_supported\")\n    val scopesSupported: List<String> = listOf(\n        \"openid\",\n        \"microprofile-jwt\",\n        \"acr\",\n        \"sign-up\",\n        \"roles\",\n        \"platform-user-id\",\n        \"web-origins\",\n        \"email\",\n        \"address\",\n        \"offline_access\",\n        \"rjf-org-test\",\n        \"organization-id\",\n        \"profile\",\n        \"phone\",\n        \"entitlements\",\n        \"name\"\n    ),\n    @SerialName(\"request_parameter_supported\")\n    val requestParameterSupported: Boolean = true,\n    @SerialName(\"request_uri_parameter_supported\")\n    val requestUriParameterSupported: Boolean = true,\n    @SerialName(\"require_request_uri_registration\")\n    val requireRequestUriRegistration: Boolean = true,\n    @SerialName(\"code_challenge_methods_supported\")\n    val codeChallengeMethodsSupported: List<String> = listOf(\n        \"S256\",\n        \"plain\"\n    ),\n    @SerialName(\"tls_client_certificate_bound_access_tokens\")\n    val tlsClientCertificateBoundAccessTokens: Boolean = true,\n    @SerialName(\"revocation_endpoint_auth_methods_supported\")\n    val revocationEndpointAuthMethodsSupported: List<String> = listOf(\n        \"private_key_jwt\",\n        \"client_secret_basic\",\n        \"client_secret_post\",\n        \"tls_client_auth\",\n        \"client_secret_jwt\"\n    ),\n    @SerialName(\"revocation_endpoint_auth_signing_alg_values_supported\")\n    val revocationEndpointAuthSigningAlgValuesSupported: List<String> = listOf(\n        \"PS384\",\n        \"ES384\",\n        \"RS384\",\n        \"HS256\",\n        \"HS512\",\n        \"ES256\",\n        \"RS256\",\n        \"HS384\",\n        \"ES512\",\n        \"PS256\",\n        \"PS512\",\n        \"RS512\"\n    ),\n    @SerialName(\"backchannel_logout_supported\")\n    val backchannelLogoutSupported: Boolean = true,\n    @SerialName(\"backchannel_logout_session_supported\")\n    val backchannelLogoutSessionSupported: Boolean = true,\n    @SerialName(\"backchannel_token_delivery_modes_supported\")\n    val backchannelTokenDeliveryModesSupported: List<String> = listOf(\n        \"poll\",\n        \"ping\"\n    ),\n    @SerialName(\"backchannel_authentication_request_signing_alg_values_supported\")\n    val backchannelAuthenticationRequestSigningAlgValuesSupported: List<String> = listOf(\n        \"PS384\",\n        \"ES384\",\n        \"RS384\",\n        \"ES256\",\n        \"RS256\",\n        \"ES512\",\n        \"PS256\",\n        \"PS512\",\n        \"RS512\"\n    ),\n    @SerialName(\"require_pushed_authorization_requests\")\n    val requirePushedAuthorizationRequests: Boolean = true,\n    @SerialName(\"mtls_endpoint_aliases\")\n    val mtlsEndpointAliases: MtlsEndpointAliases = MtlsEndpointAliases(\n        tokenEndpoint = tokenEndpoint,\n        revocationEndpoint = revocationEndpoint,\n        introspectionEndpoint = introspectionEndpoint,\n        deviceAuthorizationEndpoint = deviceAuthorizationEndpoint,\n        registrationEndpoint = registrationEndpoint,\n        userInfoEndpoint = userInfoEndpoint,\n        pushedAuthorizationRequestEndpoint = pushedAuthorizationRequestEndpoint,\n        backchannelAuthenticationEndpoint = backchannelAuthenticationEndpoint,\n    ),\n) {\n    constructor(realmUrl: String) : this(\n        issuer = realmUrl,\n        tokenEndpoint = \"$realmUrl/protocol/openid-connect/token\",\n        authorizationEndpoint = \"$realmUrl/protocol/openid-connect/auth\",\n        introspectionEndpoint = \"$realmUrl/protocol/openid-connect/token/introspect\",\n        userInfoEndpoint = \"$realmUrl/protocol/openid-connect/userinfo\",\n        jwksUri = \"$realmUrl/protocol/openid-connect/certs\",\n        registrationEndpoint = \"$realmUrl/clients-registrations/openid-connect\",\n        checkSessionIframe = \"$realmUrl/protocol/openid-connect/login-status-iframe.html\",\n        revocationEndpoint = \"$realmUrl/protocol/openid-connect/revoke\",\n        deviceAuthorizationEndpoint = \"$realmUrl/protocol/openid-connect/auth/device\",\n        backchannelAuthenticationEndpoint = \"$realmUrl/protocol/openid-connect/ext/ciba/auth\",\n        pushedAuthorizationRequestEndpoint = \"$realmUrl/protocol/openid-connect/ext/par/request\",\n    )\n\n    @Serializable\n    data class MtlsEndpointAliases(\n        @SerialName(\"token_endpoint\")\n        val tokenEndpoint: String,\n        @SerialName(\"revocation_endpoint\")\n        val revocationEndpoint: String,\n        @SerialName(\"introspection_endpoint\")\n        val introspectionEndpoint: String,\n        @SerialName(\"device_authorization_endpoint\")\n        val deviceAuthorizationEndpoint: String,\n        @SerialName(\"registration_endpoint\")\n        val registrationEndpoint: String,\n        @SerialName(\"userinfo_endpoint\")\n        val userInfoEndpoint: String,\n        @SerialName(\"pushed_authorization_request_endpoint\")\n        val pushedAuthorizationRequestEndpoint: String,\n        @SerialName(\"backchannel_authentication_endpoint\")\n        val backchannelAuthenticationEndpoint: String,\n    )\n\n    companion object {\n        fun forPort(port: Int): OpenIdConfiguration {\n            val realmUrl = \"http://localhost:$port/auth/realms/$KC_REALM\"\n            return OpenIdConfiguration(realmUrl)\n        }\n    }\n}","metadata":{"parent":null}}
{"id":"0ada1be5-69a3-4158-a3c5-84596d029e05","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/utils/OpenIdConfiguration.kt","symbol":"MtlsEndpointAliases","kind":"class","code":" @Serializable\n    data class MtlsEndpointAliases(\n        @SerialName(\"token_endpoint\")\n        val tokenEndpoint: String,\n        @SerialName(\"revocation_endpoint\")\n        val revocationEndpoint: String,\n        @SerialName(\"introspection_endpoint\")\n        val introspectionEndpoint: String,\n        @SerialName(\"device_authorization_endpoint\")\n        val deviceAuthorizationEndpoint: String,\n        @SerialName(\"registration_endpoint\")\n        val registrationEndpoint: String,\n        @SerialName(\"userinfo_endpoint\")\n        val userInfoEndpoint: String,\n        @SerialName(\"pushed_authorization_request_endpoint\")\n        val pushedAuthorizationRequestEndpoint: String,\n        @SerialName(\"backchannel_authentication_endpoint\")\n        val backchannelAuthenticationEndpoint: String,\n    )","metadata":{"parent":"OpenIdConfiguration"}}
{"id":"c69cb69d-85cd-4a1a-97d7-417e7336968f","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/utils/OpenIdConfiguration.kt","symbol":"OpenIdConfiguration.forPort","kind":"function","code":"fun forPort(port: Int): OpenIdConfiguration {\n            val realmUrl = \"http://localhost:$port/auth/realms/$KC_REALM\"\n            return OpenIdConfiguration(realmUrl)\n        }","metadata":{"modifiers":[],"annotations":[],"parent":"OpenIdConfiguration"}}
{"id":"e15dd2b5-86be-42b4-9782-c8cc451a34a8","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/utils/WireMockStubUtils.kt","symbol":"stubKeycloak","kind":"function","code":"fun stubKeycloak(port: Int, claims: JwtClaims = JwtClaims()) {\n        val realmPath = \"/auth/realms/$KC_REALM\"\n        WireMock.stubFor(\n            WireMock.post(\n                \"$realmPath/protocol/openid-connect/token\"\n            )\n                .willReturn(\n                    WireMock.aResponse()\n                        .withStatus(200)\n                        .withHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)\n                        .withBody(\n                            JsonConfig.default.encodeToString(\n                                claims.toKeycloakTokenResponse(port)\n                            )\n                        )\n                )\n        )\n\n        WireMock.stubFor(\n            WireMock.get(\"$realmPath/.well-known/openid-configuration\")\n                .willReturn(\n                    WireMock.aResponse()\n                        .withStatus(200)\n                        .withHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)\n                        .withBody(\n                            JsonConfig.default.encodeToString(OpenIdConfiguration.forPort(port))\n                        )\n                )\n        )\n\n        WireMock.stubFor(\n            WireMock.get(\"$realmPath/protocol/openid-connect/certs\")\n                .willReturn(\n                    WireMock.aResponse()\n                        .withStatus(200)\n                        .withHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)\n                        .withBody(\n                            JwtUtils.jwks\n                        )\n                )\n        )\n    }","metadata":{"modifiers":[],"annotations":[],"parent":null}}
{"id":"8c252310-3603-4f6e-94b4-32c1c0297fe6","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/utils/ContainerUtils.kt","symbol":"extractClasspathResourceToTempFile","kind":"function","code":"fun extractClasspathResourceToTempFile(classpathResource: String): String {\n        val tempFile = Files.createTempFile(\"temp\", null).toFile().apply { deleteOnExit() }\n        val classLoader = Thread.currentThread().contextClassLoader\n        classLoader.getResourceAsStream(classpathResource).use { inputStream ->\n            if (inputStream == null) {\n                throw FileNotFoundException(\"Classpath resource not found: $classpathResource\")\n            }\n            FileOutputStream(tempFile).use { outputStream -> inputStream.copyTo(outputStream) }\n        }\n        return tempFile.absolutePath\n    }","metadata":{"modifiers":[],"annotations":[],"parent":null}}
{"id":"ce0dc775-e78c-4f3f-8dae-fd9dd7b3d12b","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/utils/JwtClaims.kt","symbol":"JwtClaims","kind":"class","code":"data class JwtClaims(\n    val issuedAt: Instant = Instant.now(),\n    val expiresAt: Instant = Instant.now().plus(30.minutes.toJavaDuration()),\n    val subject: String = \"4f412f8f-cfa4-43ec-85ef-5633e3cd8f3d\",\n    val authorizedParty: String = \"Test_API_User\",\n    val roles: List<Role> = listOf(Role.ACCOUNT_OWNER),\n    val scopes: List<String> = listOf(\"email\", \"profile\", \"entitlements\", \"name\"),\n    val entitlements: List<Entitlement> = listOf(Entitlement(entitlementType = \"FULFILLMENTVU\")),\n    val organizationId: String? = \"ABCDE\",\n    val platformUserId: String? = UUID.randomUUID().toString(),\n    val clientId: String? = authorizedParty,\n    val isInternalService: Boolean? = null,\n    val emailVerified: Boolean = false,\n    val clientHost: String = \"127.0.0.1\",\n    val preferredUsername: String = \"svc-test\",\n    val clientAddress: String = clientHost,\n    val authEmail: String? = null,\n) {\n    fun toKeycloakTokenResponse(wiremockPort: Int): TokenResponse {\n        val issuer = \"http://localhost:$wiremockPort/auth/realms/$KC_REALM\"\n        val scope = scopes.joinToString(\" \")\n        val builder = JWT.create()\n            .withExpiresAt(expiresAt)\n            .withClaim(\"iat\", issuedAt)\n            .withClaim(\"jti\", UUID.randomUUID().toString())\n            .withClaim(\"iss\", issuer)\n            .withClaim(\"sub\", subject)\n            .withClaim(\"typ\", BEARER)\n            .withClaim(\"azp\", authorizedParty)\n            .withClaim(\n                \"realm_access\",\n                mapOf(\n                    \"roles\" to listOf(\n                        \"offline_access\",\n                        \"uma_authorization\",\n                        *roles.map { it.name }.toTypedArray()\n                    )\n                )\n            )\n            .withClaim(\"scope\", scope)\n            .withClaim(\"entitlements\", JsonConfig.jwt.encodeToString(entitlements))\n            .withClaim(\"email_verified\", emailVerified)\n            .withClaim(\"clientHost\", clientHost)\n            .withClaim(\"clientAddress\", clientAddress)\n            .withClaim(\"preferred_username\", preferredUsername)\n            .withClaim(\"platformUserId\", platformUserId)\n        organizationId?.let { builder.withClaim(\"organizationId\", it) }\n        authEmail?.let { builder.withClaim(\"email\", it) }\n        clientId?.let { builder.withClaim(\"clientId\", it) }\n        isInternalService?.let { builder.withClaim(\"isInternalService\", it) }\n        val accessToken = builder.sign(\n            Algorithm.RSA256(\n                JwtUtils.jwk.toRSAPublicKey(),\n                JwtUtils.jwk.toRSAPrivateKey()\n            )\n        )\n\n        return TokenResponse(\n            accessToken = accessToken,\n            expiresIn = Duration.between(\n                Instant.now(),\n                expiresAt,\n            ).seconds.toInt(),\n            refreshToken = \"B\",\n            refreshExpiresIn = 100000,\n            tokenType = BEARER,\n            notBeforePolicy = 0,\n            scope = scope,\n        )\n    }\n}","metadata":{"parent":null}}
{"id":"32aef1de-4d34-4f74-ad52-7c137c2f3765","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/utils/JwtClaims.kt","symbol":"JwtClaims.toKeycloakTokenResponse","kind":"function","code":"fun toKeycloakTokenResponse(wiremockPort: Int): TokenResponse {\n        val issuer = \"http://localhost:$wiremockPort/auth/realms/$KC_REALM\"\n        val scope = scopes.joinToString(\" \")\n        val builder = JWT.create()\n            .withExpiresAt(expiresAt)\n            .withClaim(\"iat\", issuedAt)\n            .withClaim(\"jti\", UUID.randomUUID().toString())\n            .withClaim(\"iss\", issuer)\n            .withClaim(\"sub\", subject)\n            .withClaim(\"typ\", BEARER)\n            .withClaim(\"azp\", authorizedParty)\n            .withClaim(\n                \"realm_access\",\n                mapOf(\n                    \"roles\" to listOf(\n                        \"offline_access\",\n                        \"uma_authorization\",\n                        *roles.map { it.name }.toTypedArray()\n                    )\n                )\n            )\n            .withClaim(\"scope\", scope)\n            .withClaim(\"entitlements\", JsonConfig.jwt.encodeToString(entitlements))\n            .withClaim(\"email_verified\", emailVerified)\n            .withClaim(\"clientHost\", clientHost)\n            .withClaim(\"clientAddress\", clientAddress)\n            .withClaim(\"preferred_username\", preferredUsername)\n            .withClaim(\"platformUserId\", platformUserId)\n        organizationId?.let { builder.withClaim(\"organizationId\", it) }\n        authEmail?.let { builder.withClaim(\"email\", it) }\n        clientId?.let { builder.withClaim(\"clientId\", it) }\n        isInternalService?.let { builder.withClaim(\"isInternalService\", it) }\n        val accessToken = builder.sign(\n            Algorithm.RSA256(\n                JwtUtils.jwk.toRSAPublicKey(),\n                JwtUtils.jwk.toRSAPrivateKey()\n            )\n        )\n\n        return TokenResponse(\n            accessToken = accessToken,\n            expiresIn = Duration.between(\n                Instant.now(),\n                expiresAt,\n            ).seconds.toInt(),\n            refreshToken = \"B\",\n            refreshExpiresIn = 100000,\n            tokenType = BEARER,\n            notBeforePolicy = 0,\n            scope = scope,\n        )\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"JwtClaims"}}
{"id":"32c273d9-cfb2-4417-aea1-6507bc8b8910","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/extensions/DockerEnvironmentExtension.kt","symbol":"DockerEnvironmentExtension","kind":"class","code":"interface DockerEnvironmentExtension : Extension {\n    val testContainers: StartableTestContainers\n}","metadata":{"parent":null}}
{"id":"866b4ff5-c072-4489-9b88-3d94702ed273","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/extensions/DockerEnvironmentProjectListener.kt","symbol":"DockerEnvironmentProjectListener","kind":"class","code":"open class DockerEnvironmentProjectListener(override val testContainers: StartableTestContainers,\n                                            val environmentVariablesFunction: ((StartableTestContainers) -> Map<String,String>) = { mapOf() } ):\n    SpecExtension, ProjectListener, DockerEnvironmentExtension {\n\n\n    override suspend fun afterProject() {\n        if(testContainers.isStarted()) testContainers.stop()\n    }\n\n\n    override suspend fun intercept(spec: Spec, execute: suspend (Spec) -> Unit) {\n        if (spec.extensions().any { it is DockerEnvironmentExtension && testContainers == it.testContainers } && !testContainers.isStarted()) {\n            testContainers.start()\n        }\n        val environmentVariables = if(testContainers.isStarted()) environmentVariablesFunction(testContainers) else mapOf()\n        withEnvironment(environmentVariables, mode = OverrideMode.SetOrOverride) {\n            super.intercept(spec, execute)\n        }\n    }\n\n}","metadata":{"parent":null}}
{"id":"6971e81f-5993-4234-9156-e305923084f2","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/extensions/DockerEnvironmentProjectListener.kt","symbol":"DockerEnvironmentProjectListener.afterProject","kind":"function","code":"override suspend fun afterProject() {\n        if(testContainers.isStarted()) testContainers.stop()\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"DockerEnvironmentProjectListener"}}
{"id":"3f93d71c-fb3c-4d60-bd80-52b50bfac954","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/extensions/DockerEnvironmentProjectListener.kt","symbol":"DockerEnvironmentProjectListener.intercept","kind":"function","code":"override suspend fun intercept(spec: Spec, execute: suspend (Spec) -> Unit) {\n        if (spec.extensions().any { it is DockerEnvironmentExtension && testContainers == it.testContainers } && !testContainers.isStarted()) {\n            testContainers.start()\n        }\n        val environmentVariables = if(testContainers.isStarted()) environmentVariablesFunction(testContainers) else mapOf()\n        withEnvironment(environmentVariables, mode = OverrideMode.SetOrOverride) {\n            super.intercept(spec, execute)\n        }\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"DockerEnvironmentProjectListener"}}
{"id":"f6c882b1-2f9f-4a1a-8c94-c86066e83d7a","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/extensions/EnvironmentVariableSetter.kt","symbol":"EnvironmentVariableSetter","kind":"class","code":"class EnvironmentVariableSetter(\n    private val environmentVariables: Map<String, String>\n) : SpecExtension {\n\n    override suspend fun intercept(spec: Spec, execute: suspend (Spec) -> Unit) {\n        withEnvironment(environmentVariables, mode = OverrideMode.SetOrOverride) {\n            super.intercept(spec, execute)\n        }\n    }\n}","metadata":{"parent":null}}
{"id":"8f69c351-b0d9-4663-862f-87abf3cbea58","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/extensions/EnvironmentVariableSetter.kt","symbol":"EnvironmentVariableSetter.intercept","kind":"function","code":"override suspend fun intercept(spec: Spec, execute: suspend (Spec) -> Unit) {\n        withEnvironment(environmentVariables, mode = OverrideMode.SetOrOverride) {\n            super.intercept(spec, execute)\n        }\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"EnvironmentVariableSetter"}}
{"id":"d00856b3-f1d6-4dfa-8b92-fc2e35cf1870","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/extensions/MongoEnvironmentExtension.kt","symbol":"MongoEnvironmentExtension","kind":"class","code":"class MongoEnvironmentExtension(\n    private val database: String,\n    private val username: String = \"admin\",\n    private val password: String = \"admin\",\n    private val atlasSearchDefinitions: List<String> = listOf(DEFAULT_ATLAS_SEARCH_DEFINITION_DIR),\n    private val migrationsDir: String = DEFAULT_MIGRATION_CLASSPATH_DIR,\n): DockerEnvironmentExtension, SpecExtension {\n    override val testContainers: StartableTestContainers\n        by lazy { StartableTestContainers(\n            mongoConfig = IntegrationTestMongoConfig(\n                database = database,\n                migrationClasspathDir = migrationsDir,\n                username = username,\n                password = password,\n                atlasSearchDefinitions = atlasSearchDefinitions\n            )\n        ) }\n\n    override suspend fun intercept(spec: Spec, execute: suspend (Spec) -> Unit) {\n        testContainers.start()\n        super.intercept(spec, execute)\n        testContainers.stop()\n    }\n}","metadata":{"parent":null}}
{"id":"f5ae9862-5230-450d-bb11-c834b76c6389","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/extensions/MongoEnvironmentExtension.kt","symbol":"MongoEnvironmentExtension.intercept","kind":"function","code":"override suspend fun intercept(spec: Spec, execute: suspend (Spec) -> Unit) {\n        testContainers.start()\n        super.intercept(spec, execute)\n        testContainers.stop()\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"MongoEnvironmentExtension"}}
{"id":"359a8f3c-e722-411a-89f0-1b55003cae29","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/extensions/DockerEnvironmentSpecListener.kt","symbol":"DockerEnvironmentSpecListener","kind":"class","code":"open class DockerEnvironmentSpecListener(override val testContainers: StartableTestContainers,\n                                         val environmentVariablesFunction: ((StartableTestContainers) -> Map<String,String>) = { mapOf() } ):\n  SpecExtension, DockerEnvironmentExtension {\n\n    override suspend fun intercept(spec: Spec, execute: suspend (Spec) -> Unit) {\n        beforeSpec(spec)\n        val environmentVariables = environmentVariablesFunction(testContainers)\n        withEnvironment(environmentVariables, mode = OverrideMode.SetOrOverride) {\n            super.intercept(spec, execute)\n        }\n        afterSpec(spec)\n    }\n\n    open suspend fun afterSpec(spec: Spec) {\n        testContainers.stop()\n    }\n\n    open suspend fun beforeSpec(spec: Spec) {\n        testContainers.start()\n    }\n}","metadata":{"parent":null}}
{"id":"b9c59b5d-0979-465a-9ba5-ef83e6407b96","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/extensions/DockerEnvironmentSpecListener.kt","symbol":"DockerEnvironmentSpecListener.intercept","kind":"function","code":"override suspend fun intercept(spec: Spec, execute: suspend (Spec) -> Unit) {\n        beforeSpec(spec)\n        val environmentVariables = environmentVariablesFunction(testContainers)\n        withEnvironment(environmentVariables, mode = OverrideMode.SetOrOverride) {\n            super.intercept(spec, execute)\n        }\n        afterSpec(spec)\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"DockerEnvironmentSpecListener"}}
{"id":"aa672b7d-399c-48ab-b5ca-4c9f49cdd41d","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/extensions/DockerEnvironmentSpecListener.kt","symbol":"DockerEnvironmentSpecListener.afterSpec","kind":"function","code":"open suspend fun afterSpec(spec: Spec) {\n        testContainers.stop()\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"DockerEnvironmentSpecListener"}}
{"id":"732b9455-4fc4-41e4-81b7-8a21df855a8d","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/extensions/DockerEnvironmentSpecListener.kt","symbol":"DockerEnvironmentSpecListener.beforeSpec","kind":"function","code":"open suspend fun beforeSpec(spec: Spec) {\n        testContainers.start()\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"DockerEnvironmentSpecListener"}}
{"id":"6197e06e-7bbd-4d39-8d2c-ae949ca23ea5","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/Configs.kt","symbol":"IntegrationTestContainerConfig","kind":"class","code":"abstract class IntegrationTestContainerConfig(\n    val enabled: Boolean,\n    private val persistenceStrategy: PersistenceStrategy\n) {\n    fun configure(container: GenericContainer<*>) : GenericContainer<*> {\n        persistenceStrategy.configure(container)\n        customConfiguration(container)\n        return container\n    }\n\n    open fun customConfiguration(container: GenericContainer<*>) {}\n}","metadata":{"parent":null}}
{"id":"a61a1b13-eed3-41c1-9b18-21802ade9d93","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/Configs.kt","symbol":"IntegrationTestContainerConfig.configure","kind":"function","code":"fun configure(container: GenericContainer<*>) : GenericContainer<*> {\n        persistenceStrategy.configure(container)\n        customConfiguration(container)\n        return container\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"IntegrationTestContainerConfig"}}
{"id":"2a7d9a9e-0855-40d6-acba-e15a82f18347","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/Configs.kt","symbol":"IntegrationTestContainerConfig.customConfiguration","kind":"function","code":"open fun customConfiguration(container: GenericContainer<*>) {}","metadata":{"modifiers":[],"annotations":[],"parent":"IntegrationTestContainerConfig"}}
{"id":"93eebe03-63b1-404a-ae21-da8d036ebe51","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/Configs.kt","symbol":"IntegrationTestMongoConfig","kind":"class","code":"open class IntegrationTestMongoConfig(\n    enabled: Boolean = true,\n    val enableMigration: Boolean = enabled,\n    val migrationClasspathDir: String = DEFAULT_MIGRATION_CLASSPATH_DIR,\n    val database: String = \"admin\",\n    val username: String = \"admin\",\n    val password: String = \"admin\",\n    val atlasSearchDefinitions: List<String> = emptyList(),\n    persistenceStrategy: PersistenceStrategy = EphemeralPersistence(),\n) : IntegrationTestContainerConfig(enabled,persistenceStrategy) {\n    companion object {\n        const val DEFAULT_MIGRATION_CLASSPATH_DIR = \"../infra/pulumi/pre/migrations\"\n        const val DEFAULT_ATLAS_SEARCH_DEFINITION_DIR = \"../infra/pulumi/pre/atlas-search\"\n    }\n}","metadata":{"parent":null}}
{"id":"ff29179b-e079-40eb-8426-44e990929850","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/Configs.kt","symbol":"IntegrationTestKafkaConfig","kind":"class","code":"open class IntegrationTestKafkaConfig(\n    enabled: Boolean = true,\n    val autoOffsetReset: String = \"earliest\",\n    val topicSerdes: List<Topic<*, *>>,\n    persistenceStrategy: PersistenceStrategy = EphemeralPersistence(),\n) : IntegrationTestContainerConfig(enabled,persistenceStrategy) {\n    val jksPassword: String = \"abcdef1\"\n    val keystoreLocation: String\n    by lazy {\n        ContainerUtils.extractClasspathResourceToTempFile(\"client.keystore.p12\")\n    }\n    val truststoreLocation: String\n    by lazy {\n        ContainerUtils.extractClasspathResourceToTempFile(\"kafka.truststore.jks\")\n    }\n}","metadata":{"parent":null}}
{"id":"ea772848-d625-4a87-82d1-b755b5d983ad","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/Configs.kt","symbol":"IntegrationTestWireMockConfig","kind":"class","code":"open class IntegrationTestWireMockConfig(\n    enabled: Boolean = true,\n    persistenceStrategy: PersistenceStrategy = EphemeralPersistence(),\n) : IntegrationTestContainerConfig(enabled, persistenceStrategy)","metadata":{"parent":null}}
{"id":"7490a206-8988-42f5-a896-efe6fa8af240","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/Configs.kt","symbol":"IntegrationTestGcsConfig","kind":"class","code":"open class IntegrationTestGcsConfig(\n    enabled: Boolean = true,\n    persistenceStrategy: PersistenceStrategy = EphemeralPersistence(),\n) : IntegrationTestContainerConfig(enabled, persistenceStrategy)","metadata":{"parent":null}}
{"id":"f5dd81e9-1b8f-4cc7-b1a8-4ed4f017c6a3","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/Configs.kt","symbol":"IntegrationTestBigQueryConfig","kind":"class","code":"open class IntegrationTestBigQueryConfig(\n    enabled: Boolean = true,\n    val datasetsAndTableDefs: List<DatasetInfo> = listOf(),\n    persistenceStrategy: PersistenceStrategy = EphemeralPersistence(),\n) : IntegrationTestContainerConfig(enabled, persistenceStrategy) {\n    data class DatasetInfo(\n        val name: String,\n        val tableInfo: List<TableInfo> = listOf()\n    ) {\n        data class TableInfo(\n            val name: String,\n            val serialDescriptor: SerialDescriptor\n        )\n    }\n}","metadata":{"parent":null}}
{"id":"0815ffc3-c80d-47c5-8aba-0ccc80775023","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/Configs.kt","symbol":"DatasetInfo","kind":"class","code":"data class DatasetInfo(\n        val name: String,\n        val tableInfo: List<TableInfo> = listOf()\n    ) {\n        data class TableInfo(\n            val name: String,\n            val serialDescriptor: SerialDescriptor\n        )\n    }","metadata":{"parent":"IntegrationTestBigQueryConfig"}}
{"id":"6fa6eb2f-2807-4e57-b724-607d5a41dffa","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/Configs.kt","symbol":"TableInfo","kind":"class","code":"data class TableInfo(\n            val name: String,\n            val serialDescriptor: SerialDescriptor\n        )","metadata":{"parent":"DatasetInfo"}}
{"id":"aa7532aa-41cc-45bd-b472-9b1c1a1849e2","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/Configs.kt","symbol":"IntegrationTestPostgresConfig","kind":"class","code":"open class IntegrationTestPostgresConfig(\n    enabled: Boolean = true,\n    val database: String,\n    val username: String = \"admin\",\n    val password: String = \"admin\",\n    val enableMigrations: Boolean = enabled,\n    // relative location module the changelog is relative to the migration directory\n    val migrations: List<LiquibaseMigrations> = listOf(),\n    persistenceStrategy: PersistenceStrategy = EphemeralPersistence(),\n) : IntegrationTestContainerConfig(enabled, persistenceStrategy) {\n    data class LiquibaseMigrations(\n        val changelogFile: String = \"changelog.yml\",\n        // directories to search for sql files/the changelog file\n        val directories: Set<String> = setOf(\"../migrations\"),\n        val contexts: Set<String> = setOf()\n    )\n}","metadata":{"parent":null}}
{"id":"904031b4-7b3b-4e7e-9b99-2674f8f5256a","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/Configs.kt","symbol":"LiquibaseMigrations","kind":"class","code":"data class LiquibaseMigrations(\n        val changelogFile: String = \"changelog.yml\",\n        // directories to search for sql files/the changelog file\n        val directories: Set<String> = setOf(\"../migrations\"),\n        val contexts: Set<String> = setOf()\n    )","metadata":{"parent":"IntegrationTestPostgresConfig"}}
{"id":"37e01435-08c6-46a8-af3d-d9b0f5f4db23","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/Configs.kt","symbol":"IntegrationTestRedisConfig","kind":"class","code":"open class IntegrationTestRedisConfig(\n    enabled: Boolean = true,\n    val password: String = \"password\",\n    persistenceStrategy: PersistenceStrategy = EphemeralPersistence(),\n) : IntegrationTestContainerConfig(enabled, persistenceStrategy)","metadata":{"parent":null}}
{"id":"f99658f5-5c6b-422d-8ed7-f386ac276a47","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/Configs.kt","symbol":"IntegrationTestSchemaRegistryConfig","kind":"class","code":"open class IntegrationTestSchemaRegistryConfig(enabled: Boolean = true\n) : IntegrationTestContainerConfig(enabled = enabled, persistenceStrategy = EphemeralPersistence()) {}","metadata":{"parent":null}}
{"id":"9deeb47e-7912-41de-a476-10ab6e2efb85","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/KafkaContainer.kt","symbol":"CustomListenerKafkaContainer","kind":"class","code":"open class CustomListenerKafkaContainer(dockerImage: DockerImageName) : org.testcontainers.containers.KafkaContainer(dockerImage) {\n\n    override fun configure() {\n        waitingFor(\n            Wait.forLogMessage(\".*Starting replica leader election.*\", 1).withStartupTimeout(Duration.ofMinutes(3))\n        )\n        configureZookeeper()\n    }\n\n    override fun getBootstrapServers(): String {\n        return \"INTERNAL://localhost:9093,EXTERNAL://kafka:29092\"\n    }\n\n    override fun brokerAdvertisedListener(containerInfo: InspectContainerResponse): String {\n        return \"BROKER://localhost:${getMappedPort(9092)}\"\n    }\n}","metadata":{"parent":null}}
{"id":"8b470fb3-b28a-4952-a9d8-10cd90da3aa5","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/KafkaContainer.kt","symbol":"CustomListenerKafkaContainer.configure","kind":"function","code":"override fun configure() {\n        waitingFor(\n            Wait.forLogMessage(\".*Starting replica leader election.*\", 1).withStartupTimeout(Duration.ofMinutes(3))\n        )\n        configureZookeeper()\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"CustomListenerKafkaContainer"}}
{"id":"b912f3c4-19c8-4c1b-997b-3803afe033f4","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/KafkaContainer.kt","symbol":"CustomListenerKafkaContainer.getBootstrapServers","kind":"function","code":"override fun getBootstrapServers(): String {\n        return \"INTERNAL://localhost:9093,EXTERNAL://kafka:29092\"\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"CustomListenerKafkaContainer"}}
{"id":"930b7675-a642-4780-95f9-c81e9f582298","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/KafkaContainer.kt","symbol":"CustomListenerKafkaContainer.brokerAdvertisedListener","kind":"function","code":"override fun brokerAdvertisedListener(containerInfo: InspectContainerResponse): String {\n        return \"BROKER://localhost:${getMappedPort(9092)}\"\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"CustomListenerKafkaContainer"}}
{"id":"82dafe8f-f3c7-4c87-a0ea-10c4fc875019","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/KafkaContainer.kt","symbol":"KafkaContainer","kind":"class","code":"open class KafkaContainer(\n    private val network: Network,\n    override val config: IntegrationTestKafkaConfig\n) : Container<IntegrationTestKafkaConfig>() {\n    override val dockerPort = 9092\n\n    override val container: GenericContainer<*>\n            by lazy {\n                CustomListenerKafkaContainer(DockerImageName.parse(\"confluentinc/cp-kafka:7.5.3\"))\n                    .withNetwork(network)\n                    .withNetworkAliases(\"kafka\")\n                    .withExposedPorts(dockerPort, 29092)\n                    .withEnv(\"KAFKA_SSL_KEYSTORE_LOCATION\", \"/tmp/kafka.server.keystore.jks\")\n                    .withEnv(\"KAFKA_SSL_KEYSTORE_PASSWORD\", config.jksPassword)\n                    .withEnv(\"KAFKA_SSL_TRUSTSTORE_LOCATION\", \"/tmp/kafka.server.truststore.jks\")\n                    .withEnv(\"KAFKA_SSL_TRUSTSTORE_PASSWORD\", config.jksPassword)\n                    .withEnv(\"KAFKA_LISTENERS\", \"BROKER://:9092,INTERNAL://:9093,EXTERNAL://:29092\")\n                    .withEnv(\n                        \"KAFKA_LISTENER_SECURITY_PROTOCOL_MAP\",\n                        \"BROKER:SSL,INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT\"\n                    )\n                    .withEnv(\"KAFKA_INTER_BROKER_LISTENER_NAME\", \"INTERNAL\")\n                    .withEnv(\"KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR\", \"1\")\n                    .withCopyFileToContainer(\n                        MountableFile.forClasspathResource(\"kafka.truststore.jks\"),\n                        \"/tmp/kafka.server.truststore.jks\"\n                    )\n                    .withCopyFileToContainer(\n                        MountableFile.forClasspathResource(\"kafka01.keystore.jks\"),\n                        \"/tmp/kafka.server.keystore.jks\"\n                    )\n                    .apply(config)\n            }\n\n    override val clientEnv: Map<String, String> by lazy {\n            mapOf(\n                \"BOOTSTRAP_SERVERS\" to \"localhost:$port\",\n                \"KEYSTORE_LOCATION\" to \"file:///${config.keystoreLocation}\",\n                \"TRUSTSTORE_LOCATION\" to\n                        \"file:///${config.truststoreLocation}\",\n                \"JKS_PASSWORD\" to config.jksPassword,\n            )\n        }\n\n    override fun afterStart() {\n        val adminClient =\n            AdminClient.create(\n                mapOf(\n                    AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG to\n                    \"localhost:${port}\",\n                    \"security.protocol\" to \"SSL\",\n                    \"ssl.truststore.location\" to config.truststoreLocation,\n                    \"ssl.truststore.password\" to config.jksPassword,\n                    \"ssl.keystore.location\" to config.keystoreLocation,\n                    \"ssl.keystore.password\" to config.jksPassword\n                )\n            )\n        val topicsToCreate =\n            config.topicSerdes.map { NewTopic(it.name, 1, 1) }\n        adminClient.createTopics(topicsToCreate)\n    }\n\n    private fun commonClientProps(): Properties =\n        Properties().apply {\n            this[ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG] = \"localhost:${port!!}\"\n            this[\"security.protocol\"] = \"SSL\"\n            this[\"ssl.truststore.location\"] = config.truststoreLocation\n            this[\"ssl.truststore.password\"] = config.jksPassword\n            this[\"ssl.keystore.location\"] = config.keystoreLocation\n            this[\"ssl.keystore.password\"] = config.jksPassword\n        }\n\n    fun consumerProps(): Properties {\n        val consumerProps = commonClientProps()\n        consumerProps[ConsumerConfig.GROUP_ID_CONFIG] = UUID.randomUUID().toString()\n        consumerProps[ConsumerConfig.AUTO_OFFSET_RESET_CONFIG] = config.autoOffsetReset\n\n        return consumerProps\n    }\n\n    val producerProps: Properties by lazy { commonClientProps() }\n\n    val producers: Map<String, KafkaProducer<*, *>> by lazy {\n        config.topicSerdes.associate {\n            it.name to KafkaProducer(\n                producerProps,\n                it.keySerde.serializer(),\n                it.valueSerde.serializer()\n            )\n        }\n    }\n    val consumers: Map<String, KafkaConsumer<*, *>> by lazy {\n        config.topicSerdes.associate { topic ->\n            val consumer = KafkaConsumer(\n                consumerProps(),\n                topic.keySerde.deserializer(),\n                topic.valueSerde.deserializer()\n            )\n            consumer.subscribe(listOf(topic.name))\n            topic.name to consumer\n        }\n    }\n\n    inline fun <reified K, reified V> produceRecord(topicName: String, record: Pair<K, V>) {\n        val kafkaProducer = producers[topicName] as KafkaProducer<K, V>\n        kafkaProducer.send(ProducerRecord(topicName, record.first, record.second))\n    }\n\n    inline fun <reified K, reified V> consumeRecords(\n        topicName: String,\n        expectedCount: Int,\n        duration: Duration = Duration.ofSeconds(5),\n        crossinline haltPredicate: (List<ConsumerRecord<K, V>>) -> Boolean = { false }\n    ): List<ConsumerRecord<K, V>> {\n        val consumer = consumers[topicName] as KafkaConsumer<K, V>\n        val records = mutableListOf<ConsumerRecord<K, V>>()\n\n        try {\n            Awaitility.await().atMost(duration).until {\n                val subscriptions = consumer.subscription().joinToString(\", \")\n                println(\"Consumer ${consumer.groupMetadata().groupId()} consuming from topic $topicName with subscriptions to $subscriptions\")\n                println(\"Polling records from topic $topicName\")\n                val polledRecords = consumer.poll(Duration.ofMillis(100))\n                println(\"Adding ${polledRecords.count()} records from topic $topicName\")\n                records.addAll(polledRecords.records(topicName))\n\n                records.size >= expectedCount || haltPredicate(records)\n            }\n        } catch (_: ConditionTimeoutException) {}\n\n        return records\n    }\n}","metadata":{"parent":null}}
{"id":"c2b5fbed-4b96-4e74-b3aa-0bca34cb991a","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/KafkaContainer.kt","symbol":"KafkaContainer.afterStart","kind":"function","code":"override fun afterStart() {\n        val adminClient =\n            AdminClient.create(\n                mapOf(\n                    AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG to\n                    \"localhost:${port}\",\n                    \"security.protocol\" to \"SSL\",\n                    \"ssl.truststore.location\" to config.truststoreLocation,\n                    \"ssl.truststore.password\" to config.jksPassword,\n                    \"ssl.keystore.location\" to config.keystoreLocation,\n                    \"ssl.keystore.password\" to config.jksPassword\n                )\n            )\n        val topicsToCreate =\n            config.topicSerdes.map { NewTopic(it.name, 1, 1) }\n        adminClient.createTopics(topicsToCreate)\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"KafkaContainer"}}
{"id":"c64bb95a-8863-4484-b6f8-a62bb63845b2","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/KafkaContainer.kt","symbol":"KafkaContainer.commonClientProps","kind":"function","code":"private fun commonClientProps(): Properties =\n        Properties().apply {\n            this[ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG] = \"localhost:${port!!}\"\n            this[\"security.protocol\"] = \"SSL\"\n            this[\"ssl.truststore.location\"] = config.truststoreLocation\n            this[\"ssl.truststore.password\"] = config.jksPassword\n            this[\"ssl.keystore.location\"] = config.keystoreLocation\n            this[\"ssl.keystore.password\"] = config.jksPassword\n        }","metadata":{"modifiers":[],"annotations":[],"parent":"KafkaContainer"}}
{"id":"d420164e-fbf1-4d7b-acdc-4f31a8a24dfe","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/KafkaContainer.kt","symbol":"KafkaContainer.consumerProps","kind":"function","code":"fun consumerProps(): Properties {\n        val consumerProps = commonClientProps()\n        consumerProps[ConsumerConfig.GROUP_ID_CONFIG] = UUID.randomUUID().toString()\n        consumerProps[ConsumerConfig.AUTO_OFFSET_RESET_CONFIG] = config.autoOffsetReset\n\n        return consumerProps\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"KafkaContainer"}}
{"id":"e4518d3a-9be6-4e72-8686-d32dd8cbaf47","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/KafkaContainer.kt","symbol":"KafkaContainer.produceRecord","kind":"function","code":"inline fun <reified K, reified V> produceRecord(topicName: String, record: Pair<K, V>) {\n        val kafkaProducer = producers[topicName] as KafkaProducer<K, V>\n        kafkaProducer.send(ProducerRecord(topicName, record.first, record.second))\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"KafkaContainer"}}
{"id":"14398130-66ca-4fc8-949a-1b48828161c1","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/KafkaContainer.kt","symbol":"KafkaContainer.consumeRecords","kind":"function","code":"inline fun <reified K, reified V> consumeRecords(\n        topicName: String,\n        expectedCount: Int,\n        duration: Duration = Duration.ofSeconds(5),\n        crossinline haltPredicate: (List<ConsumerRecord<K, V>>) -> Boolean = { false }\n    ): List<ConsumerRecord<K, V>> {\n        val consumer = consumers[topicName] as KafkaConsumer<K, V>\n        val records = mutableListOf<ConsumerRecord<K, V>>()\n\n        try {\n            Awaitility.await().atMost(duration).until {\n                val subscriptions = consumer.subscription().joinToString(\", \")\n                println(\"Consumer ${consumer.groupMetadata().groupId()} consuming from topic $topicName with subscriptions to $subscriptions\")\n                println(\"Polling records from topic $topicName\")\n                val polledRecords = consumer.poll(Duration.ofMillis(100))\n                println(\"Adding ${polledRecords.count()} records from topic $topicName\")\n                records.addAll(polledRecords.records(topicName))\n\n                records.size >= expectedCount || haltPredicate(records)\n            }\n        } catch (_: ConditionTimeoutException) {}\n\n        return records\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"KafkaContainer"}}
{"id":"06d2b050-0a71-4874-9b08-493fd83f0567","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/BigQueryContainer.kt","symbol":"BigQueryContainer","kind":"class","code":"open class BigQueryContainer(\n    private val network: Network,\n    override val config: IntegrationTestBigQueryConfig\n) : Container<IntegrationTestBigQueryConfig>() {\n    override val dockerPort: Int = 9050\n\n    override val container: GenericContainer<*>\n            by lazy {\n                BigQueryEmulatorContainer(\"ghcr.io/goccy/bigquery-emulator:0.4.3\")\n                    .withNetwork(network)\n                    .apply(config)\n            }\n\n    override val clientEnv: Map<String, String>\n        get() = mapOf(\n            \"PROJECT_ID\" to projectId,\n            \"BIG_QUERY_HOST\" to emulatorHttpEndpoint,\n        )\n\n    val emulatorHttpEndpoint: String\n        get() = (container as BigQueryEmulatorContainer).emulatorHttpEndpoint\n\n    val projectId: String = (container as BigQueryEmulatorContainer).projectId\n\n    val bigQueryOptions: BigQueryOptions\n        by lazy {\n            BigQueryOptions.newBuilder()\n                    .setProjectId(projectId)\n                    .setHost(emulatorHttpEndpoint)\n                    .setLocation(emulatorHttpEndpoint)\n                    .setCredentials(NoCredentials.getInstance())\n                    .build()\n        }\n\n    val service: BigQuery by lazy {\n        bigQueryOptions.service\n    }\n\n    override fun afterStart() {\n        if (config.datasetsAndTableDefs.isNotEmpty()) {\n            config.datasetsAndTableDefs.forEach {\n                service.create(DatasetInfo.of(it.name))\n                if (it.tableInfo.isNotEmpty()) {\n                    it.tableInfo.forEach { tableInfo ->\n                        val schema =\n                            BQSchemaUtils.bqSchema(\n                                tableInfo.serialDescriptor,\n                                false,\n                                false,\n                                Case.CAMEL,\n                            )\n                        val tableDef =\n                            StandardTableDefinition.newBuilder().setSchema(schema).build()\n                        service.create(TableInfo.of(TableId.of(it.name, tableInfo.name), tableDef))\n                    }\n                }\n            }\n        }\n    }\n}","metadata":{"parent":null}}
{"id":"fb1f4c7f-dd7f-4391-9846-b72717a93a7f","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/BigQueryContainer.kt","symbol":"BigQueryContainer.afterStart","kind":"function","code":"override fun afterStart() {\n        if (config.datasetsAndTableDefs.isNotEmpty()) {\n            config.datasetsAndTableDefs.forEach {\n                service.create(DatasetInfo.of(it.name))\n                if (it.tableInfo.isNotEmpty()) {\n                    it.tableInfo.forEach { tableInfo ->\n                        val schema =\n                            BQSchemaUtils.bqSchema(\n                                tableInfo.serialDescriptor,\n                                false,\n                                false,\n                                Case.CAMEL,\n                            )\n                        val tableDef =\n                            StandardTableDefinition.newBuilder().setSchema(schema).build()\n                        service.create(TableInfo.of(TableId.of(it.name, tableInfo.name), tableDef))\n                    }\n                }\n            }\n        }\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"BigQueryContainer"}}
{"id":"6416727e-b38f-4751-bbb3-191ef99d677c","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/MongoMigrationContainer.kt","symbol":"MongoMigrationContainer","kind":"class","code":"open class MongoMigrationContainer(\n    private val network: Network,\n    private val mongo: MongoContainer,\n    override val config: IntegrationTestMongoConfig,\n) : Container<IntegrationTestMongoConfig>() {\n    override val dockerPort: Int = -1\n\n    override val container: GenericContainer<*>\n            by lazy {\n                GenericContainer(DockerImageName.parse(\"us-east4-docker.pkg.dev/shared-w2g/docker-repo-ci/ci-images/mongo-migrations:stable\"))\n                    .withEnv(\"MONGO_INITDB_ROOT_USERNAME\", config.username)\n                    .withEnv(\"MONGO_INITDB_ROOT_PASSWORD\", config.password)\n                    .withEnv(\"MONGO_HOST\",\"mongodb\")\n                    .withEnv(\"MONGO_PORT\",\"27017\")\n                    .withEnv(\"MONGO_DB_NAME\",config.database)\n                    .withNetwork(network)\n                    .dependsOn(mongo.container)\n                    .withCopyToContainer(\n                        MountableFile.forHostPath(\n                            Path.of(config.migrationClasspathDir).toRealPath()\n                        ),\n                        \"/app/migrations\"\n                    )\n                    .withCommand(\"npx\", \"migrate-mongo\", \"up\", \"-f\", \"migrate-mongo-config.js\")\n                    .apply(config)\n            }\n}","metadata":{"parent":null}}
{"id":"99cd0d4c-747c-446f-ad16-f489697c5d04","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/MongoContainer.kt","symbol":"MongoContainer","kind":"class","code":"open class MongoContainer(\n    private val network: Network,\n    override val config: IntegrationTestMongoConfig,\n) : Container<IntegrationTestMongoConfig>() {\n    override val dockerPort = 27017\n\n    override val container: GenericContainer<*>\n            by lazy {\n                GenericContainer(DockerImageName.parse(\"mongodb/mongodb-atlas-local:8.0.3-20250130T181539Z\"))\n                    .withEnv(\"MONGODB_INITDB_ROOT_USERNAME\", config.username)\n                    .withEnv(\"MONGODB_INITDB_ROOT_PASSWORD\", config.password)\n                    .withExposedPorts(dockerPort)\n                    .withNetwork(network)\n                    .withNetworkAliases(\"mongodb\")\n                    .apply(config)\n            }\n\n    override val clientEnv: Map<String, String> by lazy {\n        mapOf(\n            \"MONGO_USER\" to config.username,\n            \"MONGO_PASSWORD\" to config.password,\n            \"MONGO_URL\" to \"mongodb://localhost:${port}\",\n            \"MONGO_DATABASE\" to config.database\n        )\n    }\n\n    override fun afterStart() {\n        applyAtlasSearchIndexes()\n    }\n\n    val client: MongoClient by lazy {\n        MongoClientFactory().createSyncClient()\n    }\n\n    val coroutineClient: CoroutineClient by lazy {\n        MongoClientFactory().createCoroutineClient()\n    }\n\n    protected fun applyAtlasSearchIndexes() {\n        if(config.atlasSearchDefinitions.isNotEmpty()) {\n            val client =\n                MongoClientFactory(\n                    MongoConfig(\n                        connectionString = \"mongodb://localhost:${port}\",\n                        database = config.database,\n                        user = config.username,\n                        password = config.password,\n                        applicationName = config.database\n                    )\n                ).createSyncClient()\n\n            val database = client.getDatabase(config.database)\n            config.atlasSearchDefinitions\n                .flatMap { getFiles(it) }\n                .map {\n                    val json = readSearchIndexFile(it)\n                    val indexName = json[\"name\"]!!.jsonPrimitive.content\n                    val collectionName = json[\"collectionName\"]!!.jsonPrimitive.content\n                    val collection =\n                        database.getCollection<Void>(collectionName)\n                    val createJsonCommand = buildJsonObject {\n                        val mappings = json[\"mappings\"]\n                        val analyzers = json[\"analyzers\"]\n                        put(\"mappings\", buildJsonObject { put(\"fields\", mappings!!) })\n                        analyzers?.let { an -> put(\"analyzers\", an.jsonArray) }\n                    }\n                    val command = Document.parse(createJsonCommand.toString())\n                    collection.createSearchIndex(indexName, command)\n                }\n            client.close()\n        }\n    }\n\n    private fun readSearchIndexFile(filePath: String): JsonObject {\n        val content = File(filePath).readText(Charsets.UTF_8)\n        return Json.parseToJsonElement(content).jsonObject\n    }\n\n    private fun getFiles(path: String): List<String> {\n        val file = File(path)\n\n        if (!file.exists()) {\n            throw IllegalArgumentException(\"The provided file does not exist: $path\")\n        }\n        return if(file.isDirectory) {\n            file.walk().filter { it.isFile }.map { it.toString() }.toList()\n        } else {\n            listOf(file.toString())\n        }\n    }\n}","metadata":{"parent":null}}
{"id":"66f6fa13-1a82-4916-a006-d17fa549b4ae","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/MongoContainer.kt","symbol":"MongoContainer.afterStart","kind":"function","code":"override fun afterStart() {\n        applyAtlasSearchIndexes()\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"MongoContainer"}}
{"id":"9c2a4ea3-d752-4fad-adb2-70a68832f0f3","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/MongoContainer.kt","symbol":"MongoContainer.applyAtlasSearchIndexes","kind":"function","code":"protected fun applyAtlasSearchIndexes() {\n        if(config.atlasSearchDefinitions.isNotEmpty()) {\n            val client =\n                MongoClientFactory(\n                    MongoConfig(\n                        connectionString = \"mongodb://localhost:${port}\",\n                        database = config.database,\n                        user = config.username,\n                        password = config.password,\n                        applicationName = config.database\n                    )\n                ).createSyncClient()\n\n            val database = client.getDatabase(config.database)\n            config.atlasSearchDefinitions\n                .flatMap { getFiles(it) }\n                .map {\n                    val json = readSearchIndexFile(it)\n                    val indexName = json[\"name\"]!!.jsonPrimitive.content\n                    val collectionName = json[\"collectionName\"]!!.jsonPrimitive.content\n                    val collection =\n                        database.getCollection<Void>(collectionName)\n                    val createJsonCommand = buildJsonObject {\n                        val mappings = json[\"mappings\"]\n                        val analyzers = json[\"analyzers\"]\n                        put(\"mappings\", buildJsonObject { put(\"fields\", mappings!!) })\n                        analyzers?.let { an -> put(\"analyzers\", an.jsonArray) }\n                    }\n                    val command = Document.parse(createJsonCommand.toString())\n                    collection.createSearchIndex(indexName, command)\n                }\n            client.close()\n        }\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"MongoContainer"}}
{"id":"f8298d8e-5cb6-4b3e-b046-84c664efc56a","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/MongoContainer.kt","symbol":"MongoContainer.readSearchIndexFile","kind":"function","code":"private fun readSearchIndexFile(filePath: String): JsonObject {\n        val content = File(filePath).readText(Charsets.UTF_8)\n        return Json.parseToJsonElement(content).jsonObject\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"MongoContainer"}}
{"id":"d196b580-1b10-4a6f-9410-a000643fa6b0","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/MongoContainer.kt","symbol":"MongoContainer.getFiles","kind":"function","code":"private fun getFiles(path: String): List<String> {\n        val file = File(path)\n\n        if (!file.exists()) {\n            throw IllegalArgumentException(\"The provided file does not exist: $path\")\n        }\n        return if(file.isDirectory) {\n            file.walk().filter { it.isFile }.map { it.toString() }.toList()\n        } else {\n            listOf(file.toString())\n        }\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"MongoContainer"}}
{"id":"93160ee7-3210-4921-a3c1-105fd0c5ff2f","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/GCSContainer.kt","symbol":"GCSContainer","kind":"class","code":"open class GCSContainer(\n    private val gcsMappedPort: Int,\n    private val network: Network,\n    override val config: IntegrationTestGcsConfig,\n) : Container<IntegrationTestGcsConfig>() {\n    override val dockerPort: Int = 4443\n\n    override val container: GenericContainer<*>\n            by lazy {\n                FixedHostPortGenericContainer(\"fsouza/fake-gcs-server:1\")\n                    .withExposedPorts(dockerPort)\n                    .withCommand(\"-scheme http -external-url http://localhost:$gcsMappedPort\")\n                    .withNetwork(network)\n                    .withFixedExposedPort(gcsMappedPort, dockerPort)\n                    .apply(config)\n            }\n\n    override val port: Int = gcsMappedPort\n\n    override val clientEnv: Map<String, String>\n        get() = mapOf(\n            \"GCS_HOST\" to \"http://localhost:${port}\",\n        )\n}","metadata":{"parent":null}}
{"id":"f85d51e7-d992-4723-bbdd-abe6dee63eac","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/WireMockContainer.kt","symbol":"WireMockContainer","kind":"class","code":"open class WireMockContainer(\n    private val network: Network,\n    override val config: IntegrationTestWireMockConfig\n) : Container<IntegrationTestWireMockConfig>() {\n    override val dockerPort: Int = 8080\n    override val container: GenericContainer<*>\n            by lazy {\n                GenericContainer(DockerImageName.parse(\"wiremock/wiremock:3.3.1\"))\n                    .withExposedPorts(dockerPort)\n                    .withNetwork(network)\n                    .apply(config)\n            }\n\n    val wireMockHost: String by lazy { \"http://localhost:$port\" }\n    override val clientEnv: Map<String, String> by lazy {\n            mapOf(\n                \"KC_BASE_URL\" to wireMockHost,\n                \"OAUTH_BASE_URL\" to wireMockHost,\n                \"OAUTH_REALM\" to KC_REALM,\n                \"KC_POLICY_CLIENT_ID\" to \"clientId\",\n                \"KC_POLICY_CLIENT_SECRET\" to \"secret\",\n                \"KC_APPLICATION_CLIENT_ID\" to \"clientId\",\n                \"KC_APPLICATION_CLIENT_SECRET\" to \"clientSecret\",\n                \"TRUSTED_ISSUERS_0\" to \"$wireMockHost/auth/realms/$KC_REALM\",\n            )\n        }\n\n    override fun afterStart() {\n        WireMock.configureFor(port!!)\n    }\n\n    fun stubKeycloak(claims: JwtClaims = JwtClaims()) {\n        WireMockStubUtils.stubKeycloak(port!!, claims)\n    }\n}","metadata":{"parent":null}}
{"id":"4cdc1175-afeb-4dba-a090-2785d57717b6","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/WireMockContainer.kt","symbol":"WireMockContainer.afterStart","kind":"function","code":"override fun afterStart() {\n        WireMock.configureFor(port!!)\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"WireMockContainer"}}
{"id":"3c03214f-5cbc-4b64-87e8-e0f4098a887b","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/WireMockContainer.kt","symbol":"WireMockContainer.stubKeycloak","kind":"function","code":"fun stubKeycloak(claims: JwtClaims = JwtClaims()) {\n        WireMockStubUtils.stubKeycloak(port!!, claims)\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"WireMockContainer"}}
{"id":"3e949a77-cd26-401c-ae74-0948038181d3","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/RedisContainer.kt","symbol":"RedisContainer","kind":"class","code":"open class RedisContainer(\n    private val network: Network,\n    override val config: IntegrationTestRedisConfig\n) : Container<IntegrationTestRedisConfig>() {\n    override val dockerPort: Int = 6379\n\n    override val container: GenericContainer<*>\n            by lazy {\n                GenericContainer(DockerImageName.parse(\"redis:alpine3.19\"))\n                    .withExposedPorts(dockerPort)\n                    .withNetwork(network)\n                    .withEnv(\"REDIS_PASSWORD\", config.password)\n                    .withNetworkAliases(\"redis\")\n                    .apply(config)\n            }\n\n    override val clientEnv: Map<String, String> by lazy {\n        mapOf(\n            \"REDIS_HOST\" to \"localhost\",\n            \"REDIS_PORT\" to port.toString(),\n            \"REDIS_PASSWORD\" to config.password,\n            \"REDIS_SSL\" to \"false\",\n            \"REDIS_DATABASE\" to \"1\",\n        )\n    }\n\n    val connectionProvider: IRedisConnectionProvider by lazy {\n        RedisConnectionProvider(RedisConfig(\n            host = clientEnv[\"REDIS_HOST\"]!!,\n            port = clientEnv[\"REDIS_PORT\"]!!.toInt(),\n            password = clientEnv[\"REDIS_PASSWORD\"]!!,\n            ssl = clientEnv[\"REDIS_SSL\"]!!.toBoolean(),\n            database = clientEnv[\"REDIS_DATABASE\"]!!.toInt(),\n        ))\n    }\n}","metadata":{"parent":null}}
{"id":"53146fed-a8a6-4b0f-a2c0-eed30371b708","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/PostgresContainer.kt","symbol":"PostgresContainer","kind":"class","code":"open class PostgresContainer(\n    private val network: Network,\n    override val config: IntegrationTestPostgresConfig,\n) : Container<IntegrationTestPostgresConfig>() {\n    override val dockerPort: Int = 5432\n\n    override val container: GenericContainer<*>\n            by lazy {\n                GenericContainer(DockerImageName.parse(\"postgres:12.16-alpine\"))\n                    .withEnv(\"POSTGRES_USER\", config.username)\n                    .withEnv(\"POSTGRES_PASSWORD\", config.password)\n                    .withEnv(\"POSTGRES_DB\", config.database)\n                    .withNetwork(network)\n                    .withExposedPorts(dockerPort)\n                    .withNetworkAliases(\"postgres\")\n                    .apply(config)\n            }\n\n    override val clientEnv: Map<String, String> by lazy {\n        mapOf(\n            \"PG_HOST\" to \"localhost\",\n            \"PG_PORT\" to port.toString(),\n            \"PG_USER\" to config.username,\n            \"PG_PASSWORD\" to config.password,\n            \"PG_SSL\" to \"false\",\n        )\n    }\n\n    val databaseUrl: String by lazy {\n        \"jdbc:postgresql://localhost:${port!!}/${config.database}\"\n    }\n\n    override fun afterStart() {\n        // Ensure the PostgreSQL driver is loaded\n        Class.forName(\"org.postgresql.Driver\")\n\n        // Obtain a database connection\n        withConnection { connection ->\n            val database: Database = DatabaseFactory.getInstance().findCorrectDatabaseImplementation(\n                JdbcConnection(connection)\n            )\n\n            config.migrations.forEach { migration ->\n                val clasLoader = SearchPathResourceAccessor(*migration.directories.map { DirectoryResourceAccessor(File(it)) }.toTypedArray() )\n\n                // Create Liquibase instance and run update\n                val liquibase = Liquibase(migration.changelogFile, clasLoader, database)\n                liquibase.update(Contexts(migration.contexts), LabelExpression())\n            }\n\n        }\n    }\n\n    /** Return a new JDBC connection  */\n    fun getConnection(): Connection = DriverManager.getConnection(\n        databaseUrl,\n        config.username,\n        config.password\n    )\n\n    /** Execute a block of code with a new JDBC connection and close it when finished */\n    fun <T> withConnection(block: (Connection) -> T): T = getConnection().use(block)\n}","metadata":{"parent":null}}
{"id":"d61e41f4-873e-410b-b3ad-6e784e191306","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/PostgresContainer.kt","symbol":"PostgresContainer.afterStart","kind":"function","code":"override fun afterStart() {\n        // Ensure the PostgreSQL driver is loaded\n        Class.forName(\"org.postgresql.Driver\")\n\n        // Obtain a database connection\n        withConnection { connection ->\n            val database: Database = DatabaseFactory.getInstance().findCorrectDatabaseImplementation(\n                JdbcConnection(connection)\n            )\n\n            config.migrations.forEach { migration ->\n                val clasLoader = SearchPathResourceAccessor(*migration.directories.map { DirectoryResourceAccessor(File(it)) }.toTypedArray() )\n\n                // Create Liquibase instance and run update\n                val liquibase = Liquibase(migration.changelogFile, clasLoader, database)\n                liquibase.update(Contexts(migration.contexts), LabelExpression())\n            }\n\n        }\n    }","metadata":{"modifiers":[],"annotations":[],"parent":"PostgresContainer"}}
{"id":"0d299ca7-ecc6-4d39-b9b0-e90d8bf1ec66","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/PostgresContainer.kt","symbol":"PostgresContainer.getConnection","kind":"function","code":"fun getConnection(): Connection = DriverManager.getConnection(\n        databaseUrl,\n        config.username,\n        config.password\n    )","metadata":{"modifiers":[],"annotations":[],"parent":"PostgresContainer"}}
{"id":"2f639dca-3fe9-4a83-8b49-64bf7cfe475d","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/PostgresContainer.kt","symbol":"PostgresContainer.withConnection","kind":"function","code":"fun <T> withConnection(block: (Connection) -> T): T = getConnection().use(block)","metadata":{"modifiers":[],"annotations":[],"parent":"PostgresContainer"}}
{"id":"74526313-00d4-4308-b371-5e6daea93792","file_path":"/Users/justin.mascotto/Projects/docker-integration-test/src/main/kotlin/com/w2g/docker/integration/test/containers/SchemaRegistryContainer.kt","symbol":"SchemaRegistryContainer","kind":"class","code":"class SchemaRegistryContainer(\n    private val network: Network,\n    private val kafkaContainer: KafkaContainer,\n    override val config: IntegrationTestSchemaRegistryConfig\n) : Container<IntegrationTestSchemaRegistryConfig>() {\n    override val dockerPort = 8081\n\n    override val container: GenericContainer<*>\n            by lazy {\n                GenericContainer(DockerImageName.parse(\"confluentinc/cp-schema-registry:7.1.16\"))\n                    .withNetwork(network)\n                    .withNetworkAliases(\"schemaRegistry\")\n                    .withExposedPorts(dockerPort)\n                    .withEnv(\"SCHEMA_REGISTRY_HOST_NAME\", \"localhost\")\n                    .withEnv(\"SCHEMA_REGISTRY_LISTENERS\", \"http://0.0.0.0:$dockerPort\")\n                    .withEnv(\"SCHEMA_REGISTRY_KAFKASTORE_BOOTSTRAP_SERVERS\", \"PLAINTEXT://kafka:29092\")\n                    .dependsOn(kafkaContainer.container)\n                    .apply(config)\n            }\n}","metadata":{"parent":null}}